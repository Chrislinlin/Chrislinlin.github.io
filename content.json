{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"css_練習_偽類及偽元素","text":"偽類(pseudo-cleass) 互動式的類別 以 :: 為開頭，但也可以以 : 為開頭 不存在在 document tree :hover 當滑鼠游標滑過物件時產生反應 :active 在使用者按下滑鼠按鈕並放開它之間的時間會產生反應 :focus 當元素有焦點時會對此偽類產生反應，例如：按鍵盤的 Tab 鍵所選到的元素 :nth-child() 選取第 n 個子物件，n 就是我們給予的條件，會寫至（）裡。 例子：要是我們有一串 li 標籤，然後我們想要選取奇數欄的 li，便輸入ul :nth-child(odd) 記得 ul 後面有空格 例子：要是我們一串 li 標籤，然後我們想每三個元素就把該 li 值變成紅色，便輸入ul :nth-child(3n) 括號裡是可以帶入公式的。 Demo 傳送門 偽元素(pseudo-element) 不存在在 document tree 一定要有 ==content:’可有可無內容’== 因為偽元素的初始值是 normal 計算值是 null，要是沒有 content 的話，他們就會被認定不是偽元素了 ::before/ :: after 在原始元素的內容之前/後建立的子偽元素 display 都是 inline，會產生 inline box 可以跟其他元素共享一行 瀏覽器的結果會是 Demo 編筐三角形 tags: css","link":"/2020/12/01/CSS%20%E9%81%B8%E5%8F%96%E5%99%A8/"},{"title":"Command Line 常用筆記","text":"這裡要介紹常用的 command line 指令，讓自己更熟悉使用 commandline 跟電腦溝通。 command line 基本指令介紹 要是不知道這指令什麼意思 -&gt; 好幫手「tldr」 基本指令介紹ls ls = list 列出所有檔案和路徑 寫法變化 列出隱藏的目錄：ls -a 列出詳細資料：ls -l 包上述兩個：ls -la 列出 .js 的檔案：ls *.js cd cd = change directory 切換目錄 寫法： cd '要去的目的地' 狀況：假如我想要從我們 User/apple，前往桌面上一個叫做 Chris_Coding 的資料夾，便在 iterm 輸入 1cd Desktop/Chris_Coding 原本長這樣後來就會在 Chris_Coding 的資料夾裡了 寫法變化 cd . 一個點：代表所在目錄 cd .. 兩個點：代表回去上一層目錄 ==小訣竅==：輸入 cd 空格後再按住 tab 鍵會有像打出 ls 的功能，可以選擇要去資料夾 pwd 顯示目前所在位置 cat功能有三 顯示文件所有内容 cat filename 創建一个新文件cat &gt; filename(只能創建新文件不能編輯已有文件)打完文件內容記得要按ctrl +d結束。 把文件合併成一個文件cat file1 file2 &gt; filexxx touch 碰一下檔案 寫法：touch 檔名情況一：假設檔案不存在，就會建立一個新的檔案。情況二：假設檔案存在，更改檔案些改時間。 mkdir mkdir = make directory 新增資料夾 寫法：mkdir xxx 可以先用cd xx 到你想要去的資料夾創造你想要的資料夾，就可以用mkdir xxx創造你需要的資料夾 rm rm = remove 刪除檔案 寫法: rm xxx.html 刪除某 html 檔 rmdir 刪除空資料夾，若資料夾內有檔案就無法刪除。 rm -rf 刪除整個檔案或整個資料夾 ＃謹慎使用，刪掉就真掰掰了。＊rm 檔案 就真的是刪掉檔案，使用時請小心！ mv mv = move file 用來為文件或目錄改名、或將文件或目錄移到其它位置 原本長這樣 後來變那樣 mv fileA fileB 會將 a 文件改成 b 文件 mv fileA abc(目錄) 會將 a 文件移到 abc 資料夾 mv def(目錄) abc(目錄) 要是 abc 目錄存在，會將 def 目錄移到 abc 目錄/ 要是 abc 目錄不存在，會將 def 目錄改為 abc 目錄 mv def(目錄) fileA 失敗！ sudo 取得權限 clear 清空畫面 cp cp = copy 複製檔案 寫法：cp “要複製的檔案” 123cp aaa.html bbb.html # 把檔案 aaa.html 複製一份成 bbb.htmlcp -r xx(資料夾) yy(資料夾) # 把 xx 資料夾 複製 進去 yy資料夾中 tldr當使用終端機時，我們常常會忘記如何寫命令或是不知道怎麼下筆，這時好幫手 「tldr」出現了。 tldr 是什麼？ 一個 command line 的開源工具 tldr = too long ; didn’t read （太長不想讀） 使用情況： 知道指令，但忘記怎麼用 遇到沒看過的指令，不知道如何用 安裝 tldr 打開 iterm 輸入 12brew tap tldr-pages/tldrbrew install tldr 小實驗 狀況假如我忘記 mkdir 是什麼意思？我們可以再 iterm 輸入 tldr mkdir它便會告訴我們 mkdir 的用法","link":"/2020/11/05/Command%20Line%E5%B8%B8%E7%94%A8%E7%AD%86%E8%A8%98/"},{"title":"HTML CSS Javascript 網頁三兄弟","text":"圖片來源 HTML=== HyperText Markup Language 的縮寫 中文：超文本標記語言 標記式語言是什麼？-&gt; 由很多個&lt;標籤&gt;所組成，用大小於&lt; &gt;包住你想要的 HTML 元素，結尾再用大小於包住斜線/+元素1&lt;xxx&gt;&lt;/xxx&gt; 1 構成網頁的組織架構並呈現網頁的內容（就像最上面的圖的骨頭一樣） 網頁內容包括文字、圖片、段落、表格、清單…很多標籤可以使用 範例寫法： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;first&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;fiest&lt;/h1&gt; &lt;p&gt;this is my first html&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 瀏覽器呈現結果： 寫法 一定要有&lt;!DOCTYPE html&gt;這行，因為這是告訴瀏覽器這是一個 html 檔 &lt;html&gt;&lt;/html&gt;裡面包覆著&lt;head&gt;跟&lt;body&gt;這個標籤用來包覆整個 html 的程式碼 在 與 標籤裡面的內容詳述，請詳 HTML tag 標籤介紹 CSS Cascading Style Sheets 的縮寫 中文：層疊樣式表 決定網頁的外觀長的怎樣。可以決定文字表格顏色、字體、編筐設定排版…等(就像最上面的圖他代表人的皮膚及外在的裝飾衣物) ==不可單獨使用==需搭配 html 一同使用 可以寫在 html 裡，也可以以 link 做連結，連到檔案外以.css 做結尾的檔案 內容：CSS 由多組「規則」組成。每個規則由「選擇器」（selector）、 「屬性」（property）和「值」（value）組成： 選擇器（Selector）：多個選擇器可以半形逗號（,）隔開。 屬性（property）：CSS1、CSS2、CSS3 規定了許多的屬性，目的在控制選擇器的樣式。 值（value）：指屬性接受的設定值，多個關鍵字時大都以空格隔開。 屬性和值之間用半形冒號 : 隔開，屬性和值合稱為「特性」。多個特性間用 ; 隔開，最后用 { } 括起來。 Javascipt 簡稱 JS，跟 Java 是不同的語言不要搞混 是一種腳本語言，協助我們建立動態網頁，使我們能動態的更新內容、控制多媒體、動畫……等等等。 可以寫在 html 裡，也可以另外用一個 css 以 link 做連結 tags: html、css、javascript","link":"/2020/11/07/HTML%20CSS%20Javascript%E7%B6%B2%E9%A0%81%E4%B8%89%E5%85%84%E5%BC%9F/"},{"title":"JS_Array","text":"在 JS 中，陣列是個物件，沒有長度或型別規定。 宣告 array 數組/陣列var car = [&quot;toyata&quot;, &quot;volvo&quot;, &quot;BMW&quot;]; 取得陣列值，透過索引值由 0 開始，上述例子 car[0]=&gt;toyota 改變原始陣列，有許多屬性/方法 如 push()、pop()、shift()、unshift()、reverse()、slice(a,b,c)、sort()排序…. 方法forEach() 把我們想要執行的函式，從頭到尾逐一（iterates through）的把陣列裡的元素帶進去這個函式處理一遍 語法： arr.forEach(callback, thisArg); 回傳值： undefined。 參數： callback 函式與 thisArg 1234567891011121314151617let arr = [5,10,20,30]// 沒有第二參數 thisArglet sum = 0;[1, 2, 3].forEach(function(x) { sum += x;});console.log(sum); // 6// 有第二參數 thisArg[1, 2, 3].forEach(function(x) { console.log(this);}, arr); // this -&gt;obj/*[ 5, 10, 20, 30 ][ 5, 10, 20, 30 ][ 5, 10, 20, 30 ]*/ splice(a, b, c)可以移除或新增陣列的元素，它包含了三個參數， a 是要移除或要添加的序列號碼 ( 必填 )， b 是要移除的長度 ( 選填，若不填則第一個號碼位置後方的所有元素都會被移除，若設定為 0 則不會有元素被移除 )， c 是要添加的內容 ( 選填 ) toString()/ join()方法陣列轉換成字符串 pop()/ push()把最後一個位置元素取出/新增。 1234567891011var car =[&quot;Toyota&quot;,&quot;BNW&quot;,&quot;Nisson&quot;,&quot;Honda&quot;]car.pop();var x = car.pop() //結果會是Honda pop()可以得知最後被刪除的元素push()可以得知陣列長度的元素var car =[&quot;Toyota&quot;,&quot;BNW&quot;,&quot;Nisson&quot;,&quot;Honda&quot;]car.push(&quot;Volvo&quot;);var y = car.push(&quot;Volvo&quot;) //結果會是5 slice()方法為在陣列中某個片段切出新陣列，可以指定位置（索引） 123456789101112var car =[&quot;Toyota&quot;,&quot;BNW&quot;,&quot;Nisson&quot;,&quot;Honda&quot;]var y = car.slice(2) //結果會是Nisson, Honda也可以接受兩個參數，只包含&quot;開始參數&quot;但&quot;不包括結束參數&quot;var z = car.slice(1,3) //結果會是BNW, Nisson對象`var x = {firstName:&quot;Chris&quot;, &quot;lastName:Lin&quot;}` - 用括號中間包覆著屬性當不同數據類型相加就只是連在一起 var x = 110 + &quot;Toyota&quot;; //結果是：110Toyata ...spread syntax …將剩餘的…轉換給…array。 例子：將 array array1 的內容展開給 array2(可是字串/ 函式參數/物件 ) - 之前方法使用`forEach()` 1234 var array1 = [1, 2, 3, 4]var array2 = [5, 6, 7, 8];array2.forEach( num =&gt; array1.push(num) )console.log( array1 ) // [ 1, 2, 3, 4, 5, 6, 7, 8 ] - 現在可以使用`...` 1234 var array1 = [1, 2, 3, 4]var array2 = [5, 6, 7, 8];array1 = [array1, array2]console.log( array1 ) // [ 1, 2, 3, 4, 5, 6, 7, 8 ] 參考筆記 map()將原始的變數運算後重新組合一個新的陣列。 對每個陣列元素加工 123456let arr1 =[1,2,3];let arr2 = arr1.map(element)=&gt;{ return element+1;}console.log(arr2); //arr2[2,3,4] 對陣列元素校正 123456789let arr1 =[1,2,3,4,5,6];let arr2 = arr1.map(element)=&gt;{ if(arr1&gt;3) =&gt;{ return 3; } return element;}console.log(arr2); //arr2[1,2,3,3,3,3] reduce() reduce() 進行數值加總 12345678910var myArr = [1, 2, 3];// 處理每個元素後等待回傳結果，第一次處理時代入初始值 0var result = myArr.reduce(function(prev, element) { // 與之前的數值加總，回傳後代入下一輪的處理 return prev + element;}, 0);// 6console.log(result); filter() 會回傳一個陣列，條件是 return 後面必須為 true find() 和 filter 很像都會回傳一個陣列，條件是 return 後面條件為 true，但只會回傳第一個條件為 true 的值 tags: javascript","link":"/2021/03/29/JS_Array/"},{"title":"JS_Promise","text":"Promise是 ES_6 的語法，針對 JS 做非同步的處理。非同步就是不用等上一部執行完成，才做下一步，每個步驟是可以同步執行的。一個 Promise 會帶有兩個參數，成功與失敗。 語法 1234567891011const creatPromise = new Promise((resolve, reject)=&gt;{ /**成功時回傳的**/ resolve(status) /**失敗時回傳的**/ reject(status)}).then((data)=&gt;{ /**用 then 接續成功時的處理**/}).catch((error)=&gt;{ /**用 catch 接續失敗時的處理**/ JS_fetchferch 是一個全域 windows 物件，主要是搭配 Promise 來執行請求網站和請求後獲取 Response 的處理方式。當送出 request 出去要訪問的 url，若成功則會回傳 response(裡面帶有我們想要的物件) 語法 123456fetch(url(要訪問的網頁）,{method: '方法'}(參數).then(function(response){//成功的結果}).catch(function(response){//失敗的結果}) jQuery AJAX12345678910111213141516171819202122232425262728293031323334353637383940// 使用 $.ajax() 方法$.ajax({ // 要送要求的網址(URL) url: './sample.json', // 要送出的資料 (會被自動轉成查詢字串) data: { id: 'a001' }, // 要使用的要求method(方法)，POST 或 GET type: 'GET', // 資料的類型 dataType : 'json', // 成功時要做什麼 success: function(){...}, // 失敗時要做什麼 error: function(){...},}) // 要求成功時後，要執行的程式碼 // 回應會被傳遞到回調函式的參數 .done(function( json ) { $( '&lt;h1&gt;' ).text( json.title ).appendTo( 'body' ); }) // 要求失敗時後，要執行的程式碼 // 狀態碼會被傳遞到回調函式的參數 .fail(function( xhr, status, errorThrown ) { console.log( '出現錯誤，無法完成!' ) console.log( 'Error: ' + errorThrown ) console.log( 'Status: ' + status ) console.dir( xhr ) }) // 不論成功或失敗都會執行的回調函式 .always(function( xhr, status ) { console.log( '要求已完成!' ) }) tags: javascript","link":"/2021/03/25/JS_Promise/"},{"title":"JS_練習_2022新年倒數計時器","text":"製作一個距離 2022 年一月一日的倒數計時器。 成品畫面 功能 觸碰標題會有藍光 打字動畫無限循環 時間倒數畫面呈現 CSSbody::after在跟元素body後面利用after建立一層黑模，使畫面更有質感。 123456789body::after{ content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0, .3);} body *利用z-index使 body 內部所有東西都放到最上層。 123body * { z-index: 1;} text-shadow利用屬性text-shadow 在 h1 被碰到的時候，會產生文字背影。 12345678910h1:hover{ text-shadow: 0 0 10px #3498DB, 0 0 20px #3498DB, 0 0 30px #3498DB, 0 0 40px #2980B9, 0 0 70px #2980B9, 0 0 80px #2980B9, 0 0 100px #2980B9, 0 0 150px #2980B9;} 打字動畫讓文字一個一個被打出來，可以利用 css 的step()還有overflow屬性。 step()讓元素在畫面不連續，他會依照設定的影格格數切割動畫，不補入過度動畫。 語法step(格數, position(start/ end(可省略))) number 代表我們把動畫切了幾段 position 代表動畫是從時間 開頭連續 還是結尾連續，支持start或是 end這兩個屬性值。 圖片來源: https://www.w3.org/TR/css-easing-1/#step-timing-functions - start: 表示時間開始時，已經執行了一段了 - end: 默認值。表示時間開始，才會開始執行 overflow定義元素超過某個範圍的時候該如何呈現。常見屬性: visible: 內容不會被修改，當超出元素的範圍時內容會呈現在元素框之外。 hidden: 內容會被修改，但不會顯示捲軸，當超出元素的範圍時會隱藏內容。 scroll: 內容會被修改，超出範圍自動變成捲軸方式呈現。 auto: 自動選擇由瀏覽器決定如何顯示(預設值)，當超出範圍時自動以捲軸方式呈現。 overflow-x: 可設定「水平」方向，當超出範圍時自動變成捲軸呈現方式。(需要內有寬度大於元素框的物件) overflow-y: 可設定「垂直」方向，當超出範圍時自動變成捲軸呈現方式。 overflow 小科普 white-wrap主要特性是決定如何處理元素內的空白字元，要是打字動畫打的內容長度過長，文字會被拆行。利用white-wrap 讓畫面只呈現一行。 white-wrap 小科普 JSremainTime() 先設定目前的時間變數，設定時間變數的方式是new Date() 取得剩餘的時間。將 2022 年一月一日與目前時間相減，得到剩餘時間(單位：毫秒)。 設定變數day、hour、min、sec，並用取餘數的方式，得到截至今日結束前的剩餘時間。 將剩餘時間放入 html 設定好的元素。 1234567891011121314151617181920212223//創造變數，得知現在是幾年const currentYear = new Date().getFullYear();// console.log(currentYear);//const countDownTime = new Date(`January 01 ${currentYear + 1} 00:00:00`);// console.log(countDownTime)function remainTime(){ const timeNow = new Date(); // console.log(timeNow) const remain = countDownTime - timeNow;//得到的是毫秒 // console.log(remain) //定義remain的剩下幾天幾時幾分幾秒 const sec = Math.floor(remain/1000)%60; const min = Math.floor(remain/1000/60)%60; const hour = Math.floor(remain/1000/60/60)%24; const day = Math.floor(remain/1000/60/60/24); $('#days').text(timeExpress(day)); $('#hours').text(timeExpress(hour)); $('#minutes').text(timeExpress(min)); $('#seconds').text(timeExpress(sec));} timeinterval 設定計時器，透過設定setInterval來==重複== 執行函式，設定延遲時間，在每間隔多久後再執行程式碼，最後並回傳一個 timerID。 設定條件，要是剩餘時間已經 &lt; 0，則呼叫clearInterval()以結束循環。 123456789const timeinterval = setInterval(function(){ var t = countDownTime - (new Date()); // console.log(t) if(t&lt;0){ clearInterval(timeinterval); }else{ remainTime() }},1000); tags: javascript","link":"/2021/01/28/JS%E7%B7%B4%E7%BF%92_2022%E6%96%B0%E5%B9%B4%E5%80%92%E6%95%B8%E8%A8%88%E6%99%82%E5%99%A8/"},{"title":"JS_練習_Youtube 搜尋器","text":"製作一個 youtube 搜尋頁面，讓使用者可以輸入關鍵字，依照關鍵字搜尋符合關鍵字的內容影片並有上/下頁功能的選擇。 成品畫面 功能 輸入內容 使用者輸入的內容，搜尋影片 有上一頁/ 下一頁按鈕，頁面跳轉 JS申請 API key前往一個 Google cloudclub Platform 建立專案輸入專案名稱進來專案內容後，點選建立憑證，API 金鑰點選旁邊的資訊主頁，點選啟用 API 和服務，搜尋我們這次要使用的 API Youtube Data API v3 使用$(document).ready() 確定 DOM 的完全載入 設定 key 的變數 加入 form 的 submit事件 設定防呆機制 呼叫videoSearch() videoSearch() 參數：key/ search/ maxResult 先將要展示搜尋結果那個 html 內容清除 使用 jQuery get方法，設定傳入的 url 像這邊是我們是使用 youtube 的 search API，在官方的說明文件中先貼上 search API 文件中的 urlhttps://www.googleapis.com/youtube/v3，再做其他參數欄位設定。 console.log 出來 JSON 結果的資料觀察我們需要的資料 data 裡面的 items 將每個data.items透過forEach方式取得每一筆 item 的資料，並呼叫getOutput方法創造 html 內容，將內容貼在 $('#videos')後。 創造一個 button 點擊時，會觸發getButton() getButton()判斷 token 是否為prevPageToken，並設定 button 的 html 內容屬性，及點擊會促發nextPage()與prevPage()函式。 倘若是 -&gt;會有兩個 button，Previous/ Next button。 倘若不是 -&gt; 只會有 Next button。 123456789101112function getButton(prevPageToken, nextPageToken){ let q; if(!prevPageToken){ var btnOutput = '&lt;div class=&quot;button-container&quot;&gt;' + '&lt;button id=&quot;next-button&quot; class=&quot;paging-button&quot; data-token=&quot;' +nextPageToken+'&quot; data-query=&quot;'+q+'&quot;+ onclick=&quot;nextPage();&quot;&gt;Next Page&lt;/button&gt;&lt;/div&gt;'; }else{ var btnOutput = '&lt;div class=&quot;button-container&quot;&gt;' + '&lt;button id=&quot;prev-button&quot; class=&quot;paging-button&quot; data-token=&quot;' +prevPageToken+'&quot; data-query=&quot;'+q+'&quot;+ onclick=&quot;prevPage();&quot;&gt;Previous Page&lt;/button&gt;'+ '&lt;button id=&quot;next-button&quot; class=&quot;paging-button&quot; data-token=&quot;' +nextPageToken+'&quot; data-query=&quot;'+q+'&quot;+ onclick=&quot;nextPage();&quot;&gt;Next Page&lt;/button&gt; &lt;/div&gt;'; } return btnOutput;} getOutput(item)設定一些從 JSON 檔觀察出的變數，建立成 output 字串(有標題、圖片及文字的 html 內容)，return output 內容至呼叫函式的地方。 123456789101112131415161718192021222324252627282930313233343536function getOutput(item){ var videoId = item.id.videoId; var title = item.snippet.title; var description = item.snippet.description; var thumb = item.snippet.thumbnails.high.url; var channelTitle = item.snippet.channelTitle; var videoDate = item.snippet.publishedAt; // Build Output String var output = &quot;&lt;li&gt;&quot; + '&lt;div class=&quot;list-left&quot;&gt;' + '&lt;img src=&quot;' + thumb + '&quot;&gt;' + &quot;&lt;/div&gt;&quot; + '&lt;div class=&quot;list-right&quot;&gt;' + '&lt;h3&gt;&lt;a class=&quot;fancybox fancybox.iframe&quot; href=&quot;http://www.youtube.com/embed/' + videoId + '&quot;&gt;' + title + &quot;&lt;/a&gt;&lt;/h3&gt;&quot; + '&lt;small&gt;By &lt;span class=&quot;cTitle&quot;&gt;' + channelTitle + &quot;&lt;/span&gt; on &quot; + videoDate + &quot;&lt;/small&gt;&quot; + &quot;&lt;p&gt;&quot; + description + &quot;&lt;/p&gt;&quot; + &quot;&lt;/div&gt;&quot; + &quot;&lt;/li&gt;&quot; + '&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;' + &quot;&quot;; return output;} ==＊== return 很重要，要是沒有 return 東西只是被創造出來，不會丟回去 html 裡。 nextPage() / prevPage()使用搜尋功能搜出影片後，在頁面會出現一個next page的 button，點擊促發 nextPage()函式，這裡函式跟videoSearch()很像，主要差別在，由上面我們先跑出來的 data，觀察出要帶入下一頁或上一頁的資訊必須要有一個 token，才可以帶入，這裡先定義 token 及 q 的變數，再帶入$.get中，之後跑出來的 data，一樣創造 html 內容 1234567891011121314151617181920212223242526272829303132333435//nextpage buttonfunction nextPage(){ let token = $('#next-button').data('token'); console.log(token) let q = $('#next-button').data('query'); $('#videos').html(''); $('#button').html(''); q = $(&quot;#search&quot;).val(); $.get(&quot;https://www.googleapis.com/youtube/v3/search&quot;,{ key: 'AIzaSyCSwkueGwGH8xdWDDgcMMAdXDRxKg0uEiE', type: 'video', part: 'snippet, id', pageToken: token, q: q, }, function(data){ let prevPageToken = data.prevPageToken; let nextPageToken = data.nextPageToken; console.log(data); data.items.forEach(item =&gt; { video = getOutput(item); $(&quot;#videos&quot;).append(video); }); //show button let buttons =getButton(prevPageToken, nextPageToken); $('#button').append(buttons); })} fancyboxFancyBox 是一套 jQuery 的套件，可以可以套用在圖片及影片上呈現放大燈箱的效果。 fancyBox CDN 官方 document ==注意==再 index.html 中，最後要有啟用的動作，不然會沒有效果。 1234567891011&lt;script&gt; $('[data-fancybox]').fancybox({ youtube : { controls : 0, showinfo : 0 }, vimeo : { color : 'f00' } });&lt;/script&gt; tags: javascript","link":"/2021/02/21/JS%E7%B7%B4%E7%BF%92_Youtube%E6%90%9C%E5%B0%8B%E5%99%A8/"},{"title":"JS_練習_匯率轉換器","text":"手切匯率轉換器模板，帶入匯率 API，使輸入金額即呈現轉換後的金額。 成品畫面 功能 可以選擇想要的幣別帶入當下匯率 互換幣別，轉換結果 HTML 利用 select 與 option 標籤做出下拉選單的樣式。並在每個選項有加入代表匯率幣值的值 value。 CSS 利用變數的形式，讓元素在取用顏色上面更方便 1234:root { --primary-color: #5fbaa7;}/* background: var(--primary-color); 需要使用時填入*/ 利用設定 RWD 的變化，讓畫面可以隨著螢幕的伸縮而跟著轉換。 12345@media (max-width: 600px) { .currency input { width: 200px; }} JS1. 事件利用 change/ click 事件讓使用者可以透過 輸入金額按下enter就可以得到已乘上匯率後的金額 按下 swap 執行幣別轉換，並更新金額 2. 套入 API觀察 API發現我們要的匯率資料在rates在 javascript 是利用 fetch()方法套入 API，輸入你要做的事。fetch 筆記這裡我們要執行兩件事： 將 rate 的值更改。 因為點擊 swap 而修改 因為輸入金額的修正而更改 input 的 amount 值修正。帶入更新後的 rate 與 amount-one 相乘 1234567891011121314151617function calculate() { const currency_one = $('#currency-one').val(); const currency_two = $('#currency-two').val(); fetch(`https://api.exchangerate-api.com/v4/latest/${currency_one}`) // .then(function(res) { //回傳 參數的json值 return res.json(); }) .then(function(data) { const rate = data.rates[currency_two]; $('#rate').text(`1 ${currency_one} = ${rate} ${currency_two}`); $('#amount-two').val(($('#amount-one').val() * rate).toFixed(4)); });} 3. val()在 javascript 裡要取得 value，我們會透過 物件/元素.value來取值和賦予值。 1234567// get valuevar value1 = document.getElementById('currency-one').value;var value2 = document.getElementById('currency-two').value;// assign new valuedocument.getElementById('currency-one').value = &quot;new value 123&quot;;document.getElementById('currency-two').value = &quot;new value 456&quot; 但在 jQuery 裡要透過 .val() 獲取值且利用 **val(填入要改變值)**，將值改變。 1234567// get valuevar value1 = $(&quot;.currency-one&quot;).val();var value2 = $(&quot;.currency-two&quot;).val();// assign new value$(&quot;.currency-one&quot;).val(&quot;new value 123&quot;);$(&quot;.currency-two&quot;).val(&quot;new value 456&quot;); 本次例子 我們利用 val()取值，將匯率 1 的值 賦予給 temp 將匯率 1 的值 改為匯率 2 的值。在 jQuery 裡是利用val()裡賦值 再將原來temp變數中儲存的匯率 1 的值賦予給匯率 2 最後在呼叫函式進行重新計算 1234567$('#swap').click(function(){ var temp = $('#currency-one').val(); $('#currency-one').val($('#currency-two').val()); $('#currency-two').val(temp); var currency_one = $('#currency-one').val(); var curreㄟncy_two = $('#currency-two').val(); calculate(); tags: javascript jQuery","link":"/2021/01/14/JS%E7%B7%B4%E7%BF%92_%E5%8C%AF%E7%8E%87%E8%BD%89%E6%8F%9B%E5%99%A8/"},{"title":"JS_練習_天氣API","text":"透過抓取中央氣象局的公開 API 資料，抓取台灣各縣市的當下天氣情況及未來一週天氣預報，透過下拉式選單選取不同縣市，以取得不同的天氣圖片所表示不同的天氣狀況。 成品畫面 先導入 jQuery 以及 bootstarap，透過先設定好縣市的天氣內容，以利編輯 CSS 的部分。 功能 下拉式選單選取不同縣市 顯示選取城市的當下天氣資料 顯示選取城市未來一週天氣資料及溫度 JavaScript$.ajax({})申請ＡＰＩ 到中央氣象局網站加入會員 點選取得授權碼 前往中央氣象局開放資料平臺之資料擷取 API將剛剛得到的 url 貼到想要查詢的頁面產生==URL== 利用$.ajax()輸入剛剛得到的 url 抓取中央氣象局 JSON 的資料，成功時會觸發todayWeather、selectCity與weekWeather這幾個函式。 觀察 JSON 檔，確認所需要的資料是在檔案的什麼位置，並用console.log印出來檢視內容。 在開發者工具試著打印data.location[cityNum].weatherElement，確認我們可以得到一個有 15 個氣象資訊的陣列變數。之後要取用資料時，便得確認該資料的位置帶入相關索引值。 1234567891011121314$.ajax({ url:'https://opendata.cwb.gov.tw/api/v1/rest/datastore/F-D0047-091?Authorization=CWB-373C6328-6BF2-41B3-BB3B-147802B82875&amp;format=JSON&amp;locationName=&amp;elementName=&amp;sort=time', method: &quot;GET&quot;, datatype:&quot;json&quot;, success: function(res){ data = res.records.locations[0]; // console.log(data); city = data.location; // console.log(city); todayWeather(data, cityNum); selectCity(city); weekWeather(data, cityNum); }}) todayWeather() 先把原先在 index.html 中設定的假的 html 內容先設定為空。 創造一個取得現在時間的函數，並把最後的 GMT 時區用split（）方式移除。 在$.ajax()那已確認所需資料於 JSON 檔的位置，這裡便可以直接指定變數。 將設定好的變數再度放回 index.html 中。 1234567891011121314151617181920function todayWeather(data, cityNum){ // console.log(123) $('#weatherNow').html(''); chooseCity = data.location[cityNum].locationName // console.log(chooseCity); todayDate = new Date().toString().split(&quot;GMT&quot;)[0]; let weather = data.location[cityNum].weatherElement; weatherDescription = weather[6].time[0].elementValue[0].value; let weatherTemp = data.location[cityNum].weatherElement[1].time[0].elementValue[0].value; let weatherImg = changeImg(weatherDescription); $('.weather_now').html(` &lt;h1&gt;${chooseCity}&lt;/h1&gt; &lt;h2&gt;${todayDate}&lt;/h2&gt; ${weatherImg} &lt;div class=&quot;now-description&quot;&gt;${weatherDescription}&lt;/div&gt; &lt;p&gt;溫度: ${weatherTemp} °C&lt;/p&gt; `)} selectCity()data參數是我們一開始在$.ajax()所觀察出來在 JSON 檔中的資料，再利用加上 localName 屬性，取得台灣縣市名稱。利用迴圈放入select選單中，使選單出現台灣各縣市。 1234567891011function selectCity(data){ const $ = document.querySelector.bind(document); let select = $('select'); for(let i =0;i&lt; data.length;i++){ city = data[i].locationName; let value =i; select.innerHTML += ` &lt;option value=&quot;${value}&quot;&gt;${city}&lt;/option&gt;; } // console.log(city);} changeImg()假設各式天氣狀況，當內容文字符合之時，便會秀出天氣圖片。 123456789function changeImg(weatherDescription){ if(weatherDescription === '多雲時晴' || weatherDescription === '晴時多雲' ){ return '&lt;img src=&quot;./img/sun.png&quot; alt=&quot;sun-cloudy&quot;&gt;' }else if(weatherDescription === '多雲' || weatherDescription === '陰時多雲' || weatherDescription === '多雲時陰'){ return '&lt;img src=&quot;./img/cloudy.png&quot; alt=&quot;cloudy&quot;&gt;' }else{ return '&lt;img src=&quot;./img/drop.png&quot; alt=&quot;rainy&quot;&gt;' }} 天氣圖片資料來源 weekWeather() 先將原先的 html 先清除。 將創造出的 div 給定day屬性方便做 CSS 方面的修改。 設定各項氣象資料變數。 設定時間函數取得當前時間，星期幾及時間。 將設定好的變數再度放回 index.html 中 使用append()方法將資料參數放入&lt;div id='week'&gt;&lt;/div&gt;元素後面。 1234567891011121314151617181920212223function weekWeather(data, cityNum){ $('#week').html(''); let oneWeek =['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']; let weekDay =[] for (i = 1; i &lt; 7; i++) { let timeIndex = 2 * i; let day = $('&lt;div&gt;&lt;/div&gt;').attr('class', `day`); nextWeekNum = new Date().getDay()+1; let weather = data.location[cityNum].weatherElement; weatherDescription = weather[6].time[timeIndex].elementValue[0].value; let weatherTemp = data.location[cityNum].weatherElement[1].time[timeIndex].elementValue[0].value; let weatherImg = changeImg(weatherDescription); day.html(` &lt;h3&gt;${oneWeek[i]}&lt;/h3&gt; ${weatherImg} &lt;div class=&quot;week-description&quot;&gt;${weatherDescription}&lt;/div&gt; &lt;p&gt;溫度: ${weatherTemp} °C&lt;/p&gt; `); $('#week').append(day); } change 事件將下拉式選單select綁定change事件，當選單內容改變時便會觸發·todayWeather與weekWeather函式 123456$('#select').change(function() { // console.log(123) cityNum = $('#select :selected').val(); todayWeather(data, cityNum); weekWeather(data, cityNum);}); tags: javascript","link":"/2021/02/15/JS%E7%B7%B4%E7%BF%92_%E5%A4%A9%E6%B0%A3API/"},{"title":"JS_練習_打字小遊戲","text":"製作一個打字遊戲，透過設定困難度，測試使用者在一定的時間內的打字速度及正確性。 成品畫面 成品網址 純 html 畫面 HTML 使用form、selector做出選取困難程度的表單 下方使用input標籤，讓使用者得以輸入文字測試結果 CSS雖然 html 只有用空的容器表示，但還是在 css 先設定屬性，待在 JS 呼叫時可以直接顯示。 background-color設定inherit繼承父元素的 background-color。 disflex先設定：none，等 JS 在增改屬性為flex。 z-index設定為一，讓他顯示在最上面。 1234567891011121314.end-game-container{ background-color: inherit; display: none; align-items: center; justify-content: center; flex-direction: column; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;} JS 隨機產生單字 打完單字，比較是否輸入正確 輸入正確跳下一個單字 輸入正確清除打字欄準備輸入下一個字 RandomWord() 目的：隨機產生單字 way Ｉ先定義數字陣列，設定函式 return word[]索引值。利用 Math.random 產生 0~1 的數字，再利用 Math.floor 進行 rounddown，產生整數索引值。 123456789101112131415161718192021222324252627const words= [ 'sigh', 'tense', 'airplane', 'ball', 'pies', 'juice', 'warlike', 'bad', 'north', 'dependent', 'steer', 'silver', 'hoghfalutin', 'superficial', 'quince', 'eight', 'feeble', 'admit', 'drag', 'loving'];function getRandomWord(){ return words[Math.floor(Math.random()* words.length)]} wayII使用 ajax，利用 API 得到隨機產生的單字，並放入&lt;h1&gt; 隨機產生單字 API 12345678$.ajax({ method: &quot;get&quot;, url: 'https://random-word-api.herokuapp.com/word?number=1', dataType: &quot;json&quot;, success: function (data) { $('h1').text(data); }}); input event當使用者在input輸入值，觸發事件。條件一：確認輸入值是否等於 randomWord()產生的單字條件二：當條件一成立： 執行更新分數 清除 input 欄位的值 1234567891011121314151617181920//input event listener$('#text').on('input',function(e){ const insertText = $(e.target).val(); // console.log(insertText) let randomWord = $('h1').text(); if(insertText == randomWord ){ // console.log(&quot;yes!&quot;) RandomWord(); //update the score updateScore() function updateScore(){ score++; $('#score').text(score); } //每打完一個字，clear input $(e.target).val(''); }}) focus()選取$('#text')，當畫面 reload 時，滑鼠游標自動帶到 input 裡。 12$('#text').focus(); updateTime()使設定的變數time遞減，並將值寫入$('#time')裡。要是時間到 0，執行 clearInterval() setInterval() 延遲了某段時間 (單位為毫秒)後，才執行「一次」指定的程式碼，並且會回傳一個獨立的 timer ID。 會在間隔固定的時間不斷重複，直到呼叫clearInterval()。 setInterval 小科普 setTimeout() 是固定延遲了某段時間之後，才去執行對應的程式碼，然後 ==不斷循環==。 當然也會回傳一個獨立的 timer ID。 只會執行一次就結束。 setTimeout 小科普 clearInterval() 可以取消由 setInterval() 設定的 timeout。 clearInterval 小科普 123456789function updateTime(){ time--; $('#time').text(time + 's'); if(time === 0){ clearInterval(timeInterval); gameOver(); }} gameOver()當遊戲結束，將原先 html 設置的&lt;div id=&quot;end-game-contianer&quot;&gt;寫上遊戲結束的內容，並將其容器的 css 屬性改為display:flex location.reload():是一個放讓瀏覽器重新整理的方法。 location.reload()小科普 1234567function gameOver(){ $('#end-game-container').html(` &lt;h1&gt;Time ran out&lt;/h1&gt; &lt;p&gt;Your final score is ${score}&lt;/p&gt; &lt;button onclick= &quot;location.reload()&quot;&gt;Reload&lt;/button&gt; `).css('display','flex');} setting difficulty 設定遊戲的困難度是由存放在 localstorage 的困難度還是是直接設定medium。 當畫面 reload 時，困難度不會改變，會按照之前所選的困難度。 123456//設定困難度是由設定在localstorage的困難度還是'medium'// let difficulty = 'medium';let difficulty = localStorage.getItem('difficulty') !==null? localStorage.getItem('difficulty') : 'medium';//set difficulty select value$('#difficulty').val(localStorage.getItem('difficulty') !==null? localStorage.getItem('difficulty') : 'medium'); tags: javascript","link":"/2021/01/22/JS%E7%B7%B4%E7%BF%92_%E6%89%93%E5%AD%97%E5%B0%8F%E9%81%8A%E6%88%B2/"},{"title":"JS_練習_無限轉軸頁面","text":"製作一個無限捲軸的搜尋頁面，並依照關鍵字搜尋假文 成品頁面 功能 按照搜尋關鍵字搜尋符合之假文 HTML先利用 html 寫上假設的項目列表，以利方便設定 css 的樣式。 最上面用一容器包覆&lt;input&gt;製作可搜尋的欄位， 中間則是容器，包覆搜尋的項目。 最下面為 loading point。 CSS 單位 px：像素，無法像公分或是公尺具體化一像素寬多少/高多少，像素的寬跟高是依顯示器的解析度做判斷。 em：相對單位。繼承父層元素的寬高設定，要是沒有父層元素就是瀏覽器的根元素預設設定（瀏覽器預設字體大小為 16px)。 vh/vw：相對單位。根據可視視窗寬高決定百分比伸縮的單位。語法上省略%這個符號，數值後面直接接 vw 跟 vh。 &lt;tag&gt;:nth-of-type(n)選取器 選取第 n 個同類型標籤的子物件，n 可以是odd、even或是數字。 123.circle:nth-of-type(2){ /* 迭代選擇器，選到第二個點點 */ animation-delay: .1s ;} JS 實現步驟 進入頁面時，假文自 API 取出，出現在頁面。 輸入搜尋字，出現 loading point。 符合搜尋字之內容，排序出來。 showPost() 目的：從 jsonplaceholder API 取得假文。利用 jQuery 版本的 ajax， 什麼是 ajax: 非同步的 JavaScript 與 XML 技術，一種不需要重新整理頁面，透過 JavaScript 跟伺服器交換資料、更新網頁內容的技術。 同步/非同步- 同步是看按照任務順序做，前一個任務完成才會做下一個任務。 - 非同步是，大家一起做，沒有誰先誰後 語法： 1234567891011121314$.ajax({ url:, method:, dataType:, data: success:function(res){console.log(res)}, error:function(err){console.log(err)},});//url: 要請求資料的網址//method: 請求資料的方式(Ex:POST / //GET / PUT...等)//dataType: 請求資料的類型(Ex:xml, json, script, or html...等)//data: 如果需要傳送資料時，則將資料設定在這裡。 本次例子程式碼，先利用 console.log 看看 data 是否取出成功。 123456789101112let limit = 5let page = 1 $.ajax({ url: `https://jsonplaceholder.typicode.com/posts? _limit=${limit}&amp;_page=${page}`, method: 'get', dataType: 'json', success: function (data) { console.log(data); } }) 取出成功 將取出來的資料，使用 forEach，遍及每筆資料，利用 jQuery 創造元素的方式$('&lt;div&gt;&lt;/div&gt;')，加上屬性將取出之假文資料放入設定內容。 123456789data.forEach(function(post){ const postEl = $('&lt;div&gt;&lt;/div&gt;').addClass('post'); postEl.html(` &lt;div class=&quot;number&quot;&gt;${post.id}&lt;/div&gt; &lt;div class=&quot;post-info&quot;&gt; &lt;h2 class =&quot;post-title&quot;&gt;${post.title}&lt;/h2&gt; &lt;p class = &quot;post-body&quot;&gt;${post.body}&gt;&lt;/p&gt; &lt;/div&gt; `) scroll event 設定條件:當整個頁面(widtj 的滾動距離 + 目前顯示視窗的高度 &gt; (整個頁面的高度 - 5)在接近底部時，出現 loading point 並觸發函式showPost()繼續產生假文 12345$(window).scroll(function(){ if ($(document).scrollTop() + $(window).height() &gt; $(document).height() - 5) { showLoading(); }}) 元素的寬度/高度圖片來自：https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements 絕對位置 offsetWidth/ offsetHeight：元素本身+邊界+padding+捲軸 client：元素裡的==子元素==的寬高 +padding (!沒有邊界跟捲軸) scroll：元素內的子元素的寬高，要是子元素超出捲軸外，也包含超出部分，在沒有捲軸時，scroll 就等於 client 相對位置 offset:元素本身相對於母元素的水平/垂直距離 client: 元素本身內外水平/垂直距離，就是邊界的寬高 scrollTop/ scrollLeft:常用！內容被捲動的距離，內容頂端跟捲軸頂端的相對距離。 scrollTop:表示滾動的高度 scrollTop()-&gt;設定滾動的高度/ 取得滾動的高度 12取得滾動的高度： var scrollTop = document.documentElement.scrollTop setTimeout()設置定時器，等時間倒數完畢，就執行一段函式或程式碼。 語法 123var timeoutID = scope.setTimeout(function[, delay, param1, param2, ...]);var timeoutID = scope.setTimeout(function[, delay]);var timeoutID = scope.setTimeout(code[, delay]); setTimeout 小科普 filterSearch()使用者在 input 輸入搜尋值，會顯示符合搜尋值的 post 出來。 1234function filterSearch(){ const text = $('input').val().toLowerCase(); $('.post').css('display','none') $(`.post:contains('${text}')`).css('display','flex');} contain 小科普 tags: javascript","link":"/2021/01/21/JS%E7%B7%B4%E7%BF%92_%E7%84%A1%E9%99%90%E8%BD%89%E8%BB%B8%E9%A0%81%E9%9D%A2/"},{"title":"JS_練習_記帳本","text":"製作一個記帳簿，可以增加收入及支出，並呈現加總金額。 成品畫面： 成果網頁 功能 每個品項記載名稱及金額，並依照金額給予特定屬性。 單一頁面實現新增、刪除品項及各項加總。 html 中間的 HISTORY 是用容器包覆著ul，每筆新增的項目會表示在ul裡及form 最下面則是用form讓使用者填寫新增的項目。 css 使用變數儲存陰影的設定，可以迅速且方便的取用。 12345:root{ --box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0.24); /*取用時以box-shadow: var(--box-shadow)即可取用*/} 在選擇器上，使用&lt;tag&gt;:first-of-type指的是某父元素下相同型別子元素中的第一個，像是本次div:first-of-type 就是在某父型別下的第一個 div。 first-type-of 小科普 在容器右邊設定邊線，達成中間有分隔線的效果。 123.inc-exp-container &gt;div:first-of-type{ border-right: 1px solid #dedede} 在父元素容器，進行切分，利用 flex 設定為一，使子元素自動平分空間 1234.inc-exp-container &gt;div{ flex: 1; text-align: center;} JavaScript步驟 輸入要新增的內容呈現在上面列表 上面列表內容金額自動加總 金額正數呈現綠色，金額負數呈現紅色 點選刪除鍵，總金額自動計算，列表內容刪除 addItem()使輸入的項目，新增至上方 HISTORY，同時也新增一個刪除按鈕。 將原先li標籤設定 minus 屬性，並設定參數條件，若符合條件，則移除 minus 屬性並新增 plus 屬性。 當選擇在 history 刪除項目時，點選==x==觸發事件，記得要加上last()，不然會把所有輸入的項目都刪掉，不會只刪一個。 last 小科普 append()/ appendTo()兩種方法功能相同，都是將目標加入容器之後但語法不同。 (表達式).append(參數) (加入物（參數)).appendTo(容器(表達式)) 12345678910111213141516171819//add item in historyfunction addItem(name, amount, id ,transactions){ var item_str = '&lt;li class =minus&gt;'+name+'&lt;span&gt;'+amount+'&lt;/span&gt;'+'&lt;button class = &quot;delete-btn&quot; data-id=&quot;'+id+'&quot;&gt;x&lt;/button&gt;'; $('#list').append(item_str) if(amount&gt;0){ $('li').toggleClass('minus') $('li').addClass('plus') } clearForm(); $('.delete-btn').last().click(function(){ $(this).parent().remove(); var id =$(this).data('id'); deleteItemFormLocalstorage(transactions, id); updateValues(); })} append to 小科普 localstorage建立一個變數transactions，將儲存在 localstorage 的資料拉出來，並利用JSON parse()將拉出來的資料轉換成陣列形式。 1var transactions = JSON.parse(localStorage.getItem('myTransactions')) || []; generateID() 產生亂數代表決定我們要在列表新增多少項目。 Math.random():會產生 0~1 間的小數。 Math.floor():會將小數點捨去並回傳小於等於產生的亂數的最大整數。 乘上 100000 倍，代表產生亂數的數量。 123function generateID(){ return Math.floor(Math.random()*1000000)}; clearform ()每當新增項目時(要在 addItem()呼叫它)，會清除使用者輸入欄的值，讓使用者得進行下一次的輸入。 1234function clearForm(){ $('#form').find(&quot;input&quot;).val(&quot;&quot;);} deleteItemFormLocalStorage()設定條件，要是 id 完全符合時，使用 splice()方法，刪除陣列項目，再利用使用JSON.stringify，將資料陣列轉為字串重新更新 localstorage。 splice()小科普 123456789function deleteItemFormLocalstorage(transactions, id){ transactions.forEach(function(item, index, arr){ if(item.id === id){ arr.splice(index, 1); } }); localStorage.setItem('myTransactions', JSON.stringify(transactions));} 123456789101112131415161718var transactions = JSON.parse(localStorage.getItem('myTransactions')) || [];$(document).ready(function(){ if(transactions.length &gt;0){ initHistory(transactions); } $(&quot;#form&quot;).find('button').click(function(e){ e.preventDefault(); var name = $('#text').val(); var amount = $('#number').val(); var id = generateID() addItem(name, amount, id, transactions); //push（）讓陣列可以丟進內容 transactions.push({id: id, name: name, amount: amount}); localStorage.setItem('myTransactions', JSON.stringify(transactions)); updateValues(); })}) updateValue() 處理陣列的金額，利用map()運算回傳新的陣列 每一筆交易加總，使用reduce()方法，抓取每一項目的金額進行加總 reduce() 123const sum = array.reduce((accumulator, element) =&gt; { return accumulator + element;}, 0); reduce()小科普 計算收入/ 支出/ 總數金額，使用filter()方法，設定函式計算，經過運算，回傳新的陣列。 filter() 得到元素/ 物件集合中的符合的表達式，把要的物件/元素選出來 12345678&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt; &lt;li&gt;list item 6&lt;/li&gt;&lt;/ul&gt; 1$('li').filter(':even').css('background-color', 'red'); 那選出來的元素會是索引號為偶數得物件，然後我們用 css 讓他變紅色 filter()小科普 加入內文至選定的元素 在函式 initHistory 及點擊事件時呼叫他，使事件發生時能更新資訊。 1234567891011121314151617181920212223242526272829303132333435363738394041function updateValues() { const amounts = transactions .map(function(transaction) { return transaction.amount; }) // reduce()方法：累加陣列中數值 const total = parseFloat(amounts .map(Number) //單純的amount是字串陣列 .reduce((function(accumulator, item_str) { return accumulator += item_str; // accumulator = accumulator + item; }),0)) .toFixed(2); // console.log(total) // filter()方法： 經過內部函式處理後，將通過之元素回傳為新陣列 // https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/filter const income = parseFloat(amounts .filter(function(item_str) { return item_str &gt; 0; }) .reduce((function(accumulator, item_str) { return accumulator -= item_str; }),0))*-1 .toFixed(2); console.log(income) const expense = parseFloat((amounts .filter(function(item_str) { return item_str &lt; 0; }) .reduce((function(accumulator, item_str) { return accumulator -= item_str; //acc=acc-item }),0) * -1)) .toFixed(2); // console.log(expense) $('#balance').text(`$${total}`); $('#money-plus').text(`$${income}`); $('#money-minus').text(`$${expense}`);} initHistory()用 forEach()方法跑一次物件的資料，等呼叫函式時，可以直接顯示。 123456function initHistory(transactions){ transactions.forEach(function(item){ addItem(item.name, item.amount, item.id, transactions)//item.id也要記得加 }) updateValues();} tags: javascript","link":"/2021/01/17/JS%E7%B7%B4%E7%BF%92_%E8%A8%98%E5%B8%B3%E6%9C%AC/"},{"title":"JS_練習_電影院選位頁面","text":"製作一個電影訂位的網頁，可以透過選取的座位數以及不同的電影，呈現不同的票價。 最終畫面呈現： 成果網頁 成品功能 可以選擇不同電影 可以選擇座位 加總選取座位配合搭配電影的票價獲得消費總額 頁面重新整理時，資料保有在原始頁面 HTML 用 select and option 做出下拉式選單，並在 option 後帶入代表票價的 value 123456789&lt;div class=&quot;movie-container&quot;&gt; &lt;label&gt;Pick a movie:&lt;/label&gt; &lt;select id=&quot;movie&quot;&gt; &lt;option value=&quot;10&quot;&gt;Avengers: Endgame ($10)&lt;/option&gt; &lt;option value=&quot;12&quot;&gt;Joker ($12)&lt;/option&gt; &lt;option value=&quot;8&quot;&gt;Toy Story 4 ($8)&lt;/option&gt; &lt;option value=&quot;9&quot;&gt;The Lion King ($9)&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 用 ul 及 li 做出座位狀態表，再利用容器 div 給予屬性裡面包覆很多小容器代表座位。 123456789101112131415161718192021222324252627&lt;ul class=&quot;showcase&quot;&gt; &lt;li&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;small&gt;N/A&lt;/small&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;seat selected&quot;&gt;&lt;/div&gt; &lt;small&gt;Selected&lt;/small&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;seat occupied&quot;&gt;&lt;/div&gt; &lt;small&gt;Occupied&lt;/small&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;screen&quot;&gt;&lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat occupied&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat occupied&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;/div&gt; 利用標籤 p 做出選取的座位數及票價的文字呈現，並利用 span 標籤讓帶入 JS 時可以更方便選取。 123456&lt;p class=&quot;text&quot;&gt; You have selected &lt;span id=&quot;count&quot;&gt;0&lt;/span&gt; seats for a price of $&lt;span id=&quot;total&quot; &gt;0&lt;/span &gt;&lt;/p&gt; CSS網頁整體以 flex 為主，只要設定致中，版面設置滿版 appearance 由於不同瀏覽器的支援不同，針對不同瀏覽器的預設樣式修正。 macOS使用的safari需要-webkit-appearance: none;來防止預設的瀏覽器樣式。 12345.movie-container select { -moz-appearance: none; -webkit-appearance: none; appearance: none;} 先設定好選擇好的座位及特定的座位的 css，就算一開始 html 沒有在標籤內填入這些屬性也可之後ＪＳ帶入時，直接更改 classname 就可套用設定好的 css。 12345678910111213141516171819202122232425.seat.selected { background-color: #6feaf6; /*已選擇座位顏色*/}.seat.occupied { background-color: #fff;}.seat:nth-of-type(2) { /*利用特定位置選擇器做出走道*/ margin-right: 18px;}.seat:nth-last-of-type(2) { /*利用特定位置選擇器做出走道*/ margin-left: 18px;}.seat:not(.occupied):hover { /*選擇器 =&gt; 未被選擇座位碰觸時放大*/ cursor: pointer; transform: scale(1.2);}.showcase .seat:not(.occupied):hover { /*選擇器 =&gt; 上方示意區域取消效果*/ cursor: default; transform: scale(1);} 電影螢幕透過 css 3D 透視效果及搭配本身螢幕容器設定transform:rotate屬性及box-shadow屬性做出類似電影院的效果 12345678910111213.container { perspective: 1000px; /*3D效果*/ margin-bottom: 30px;}.screen { background-color: #fff; height: 70px; width: 100%; margin: 15px 0; transform: rotateX(-45deg); box-shadow: 0 3px 10px rgba(255, 255, 255, 0.7);} JS 宣告變數，要是變數之後還會改變，就會利用let 12let ticketPrice = +$('#movie').val();//jquery沒有'.value&quot; 只有val()let seats = $('.row .seat:not(.occupied)'); 用 click 事件呼叫 callback function，且利用toggle屬性，將參數未有的標籤加上，有的標籤去除。 用 click 事件方式呼叫 callback function 用.target 得到元素並用toggle() 判斷在函式中判斷參數是否含有某 class。target 小科普 用 if 條件判斷符合，就可以在使用 toggle()加入 selected 屬性使他變色 最後呼叫一次updateSelectedCount() 函式，讓我們每產生點擊事件一次，即可更新下方文字敘述。 123456789$(document).ready(function(){ $('.container').click(function(e){ if(e.target.classList.contains('seat') &amp;&amp; !e.target.classList.contains('occupied')){ e.target.classList.toggle('selected'); //因為用toggle 會把沒有的變成有，若有的就會變沒有 updateSelectedCount(); } });}); 使用者可以自由選擇座位，但已選的不能選 編寫步驟如下： 把選取的座位放到 arr 用 map()方法更新 arr 在 return 到新的 arr 利用...運算來將我們選取的位置傳入[]成為陣列array， 利用map()這個方法處理陣列中的元素，返回我們選取的位置在陣列中的索引值(在陣列中哪個位置，從零開始，利用indexOf()方法)。 將取得的索引值存入localStorage，給定兩個參數（keyName, keyValue)，第一個參數作用是給定名稱，稱為keyName(鍵名) =&gt; 下面這個例子叫做selectedSeats第二個參數作用是給定值，稱為keyValue(鍵值)也就是這個keyName對應的值。但keyName和keyValue都必須是字串型別，所以用JSON.stringify()將陣列轉成字串型別。LocalStorage 筆記傳送門 1234567891011121314151617function updateSelectedCount(){ $(document).ready(function(){ const selectSeats = $('.row .seat.selected'); const selectedSeats = $('.row .seat.selected'); const seatsIndex = [...selectedSeats].map(function(seat){ return [...seats].indexOf(seat); }) localStorage.setItem('selectedSeats', JSON.stringify(seatsIndex)); const selectedSeatsCount = selectSeats.length; $('#count').text(selectedSeatsCount); $('#total').text(selectedSeatsCount * ticketPrice) ; }); 使用者可以選擇電影，帶入不同的價格 123456$('#movie').change(function(e){ ticketPrice = $(e.target).val(); setMovieData(e.target.selectedIndex, $(e.target).val()); //這個selectedIndex在哪 updateSelectedCount();}) 每選一個位置，位置圖下有數量跟座位數的正比關係 123456789101112131415161718 function updateSelectedCount(){ $(document).ready(function(){ const selectSeats = $('.row .seat.selected'); const selectedSeats = $('.row .seat.selected'); const seatsIndex = [...selectedSeats].map(function(seat){ return [...seats].indexOf(seat); }) localStorage.setItem('selectedSeats', JSON.stringify(seatsIndex)); const selectedSeatsCount = selectSeats.length; $('#count').text(selectedSeatsCount); $('#total').text(selectedSeatsCount * ticketPrice) ; });} 使用 local Storage 儲存已選的座位，並將其取出後附加屬性 為了使頁面重整後依然能夠保有選取的位置，在每次選取時將內容儲存至瀏覽器的儲存空間，需要時再取出套用其他屬性。 使用 JSON.parse 把 JSON 資料轉換 array 回來，使用 getItem 到我們要使用的 key(selectedSeats)取得 value 並且指派給變數 selectedSeats 使用兩個判斷式 第一個判斷式：條件為selectedSeats不為空值，且localStorage至少需要一個值。 通過第一個判斷式會透過each()方法，檢查selectedSeats索引值是否存在其中。 第二個判斷式：要是透過indexOf()確認索引值存在其中，indexOf 會大於-1 通過第二個判斷式就會加上屬性selected 1234567891011121314151617 const selectedSeats = JSON.parse(window.localStorage.getItem('selectedSeats')); //將localStorage的資料加入 selected屬性 if(selectedSeats !== null &amp;&amp; selectedSeats.length &gt;0){ seats.each(function(index, seat){ //indexOf&gt; -1代表該資料在arr 中 if(selectedSeats.indexOf(index)&gt;-1){ seat.classList.add('selected'); } }); }// 在jquery裡 foreach的方式是 .each(function(index,element))和JS相反，js是foreach(function(element, index)) const selectedMovieIndex =window.localStorage.getItem('selectedMovieIndex'); if(selectedMovieIndex !== null){ $('#movie').selectedIndex = selectedMovieIndex; };} tags: javascript jQuery","link":"/2020/12/05/JS%E7%B7%B4%E7%BF%92_%E9%9B%BB%E5%BD%B1%E9%99%A2%E8%A8%82%E4%BD%8D%E9%A0%81%E9%9D%A2/"},{"title":"JS_練習_音樂播放器","text":"建立一個音樂播放器使使用者能自由播放音樂，選取想要播放的音樂位置，調整音量及曲目。 成品頁面 成品功能 播放/ 暫停音樂 選擇前一首歌/ 下一首歌， 根據總曲目數量，設定條件讓歌曲循環播放 設定進度條，使使用者決定歌曲的播放位置 HTMLaudio:使用 audio 標籤並放上 src，讓網頁能夠輕鬆載入音樂檔 csstranform: translate透過給定目標位置距離起始元素的 left(x 座標)&amp;top 距離(y 座標)，使元素從其當前位置移動。 1transform: translate(50px, 100px); width: 用來控制網頁元素寬度- auto:自動判斷網頁元素的寬度。 - 數字＋單位：可接受的單位有 px, em, cm 等網頁標準單位 - ％：利用百分比設定網頁元素寬度，需要有比較的參考 - inherit：繼承自父層的寬度屬性值。（IE不支援） animation: 設定動畫 animation 常見屬性： animation-name:動畫名稱 animation-duration：動畫持續時間，預設 0，單位 s 或 ms。 animation-deplay：動畫延遲播放時間，預設 0，單位 s 或 ms。 animation-play-state:動畫播放或暫停狀態，預設 running。其他還有 paused。 animation-iteration-count:動畫播放次數，預設 1。還有==infinite== 重複播放 animation-timing-function:動畫加速度函式，預設 ease。其他還有： linear、ease-in、ease-out、ease-in-out，step-start、step-end、steps(int,start/end)、cubic-bezier(n,n,n,n)。 123/*----------可用縮寫--------------*/animation:name duration | timing-function | delay | iteration-count | play-state; 在設定好動畫屬性時，設定關鍵影格 keyframe，可以使用 from…to… 也可以使用 0%~100%設定 123456789@keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } opacityopacity：被選定的元素的透明度。本次練習，先將 opacity 設定為 0，使其消失，待增加 play 屬性後，將 opacity 設定為 1，使其顯現。 123456789101112131415161718.music-info{ background-color: rgba(255, 255, 255, .5); border-radius: 15px 15px 0 0; position: absolute; top: 0; left: 20px; width: calc(100% - 40px); padding: 10px 10px 10px 150px; opacity: 0; transform: translateY(0%); transition: transform 0.3s ease-in, opacity 0.3s ease-in; z-index: 0;}.music-container.play .music-info { opacity: 1; transform: translateY(-100%); } z-index 利用 z-index 屬性，將選取的元素往上排列顯示。 123456789.music-container{ background-color: #fff; box-shadow: 0 20px 20px 0 rgba(252, 169, 169, .6); display: flex; padding: 20px 30px; margin: 100px 0; z-index: 10; position: relative;} z-index 小科普 object-fitobject-fit 屬性使元素去適應定義好寬高的&lt;html 標籤&gt;。本次例子使用該屬性，讓歌曲圖片可以更適應容器 常見的屬性： fill:預設的效果，也就是圖片會變得跟框框一樣大且若跟保留的框框比例不一樣會變形。 contain: 圖片完整且剛好放進去。 cover: 圖片剛好填滿。 none: 圖片不做縮放但還是限制在框框的範圍。 1234567891011.img-container img{ border-radius: 50%; height: 100px; width: inherit; position: absolute; animation: rotate 3s linear infinite; /* animation-play-state: paused; 狀態是暫停的 */ bottom: 0; left: 0; object-fit: cover;} object-fit 小科普 JS實現步驟： 點擊按鈕播放歌曲，再次點擊按鈕，暫停歌曲。 點擊按鈕可選擇往前一首曲目或往後一首曲目。 利用歌曲進度條，調整曲目的不同資訊 play/ pause() 透過點擊 button 觸發播放歌曲函式，使其addclass('play')增加 play 屬性，pause()則是removeClass，帶入已設定好的 css 設定。 透過 find()方法找到包含('i.fas')的元素。 移除('fa-play')屬性 增加('fa-pause')屬性 利用 audio.play()播放音樂，暫停音樂則是 audio.pause()。 123456function playSong(){ musicContainer.addClass('play') playBtn.find('i.fas').removeClass('fa-play'); playBtn.find('i.fas').addClass('fa-pause'); audio.play();} prevSong()/ nextSong() 利用每點擊一次 prevBtn，觸發函式，讓 songIndex 減一 設定條件讓 songIndex 不會一直小下去，因為原本的歌曲陣列 songIndex 只有 0、1、2 執行loadSong()讓曲目圖片改變歌曲也改變 執行playSong()播放歌曲 1234567891011121314prevBtn.click(function(){ prevSong();})function prevSong(){ songIndex--; console.log(songIndex) //不然index會一直小下去但原本的index只有 0,1,2 if(songIndex&lt; 0){ songIndex = songs.length -1 } loadSong(songs[songIndex]); playSong()} setProgress()目的：點擊進度條，可以選取所選歌曲的播放位置。 123456789101112progressContainer.click(function(){ setProgress();})function setProgress(){ const width = this.clientWidth; // console.log(width); const clickX = e.offset().left; // console.log(clickX); const duration = audio.duration; audio.currentTime = (clickX/width) *duration;} timeupdate event目的：隨著歌曲的播放更新進度條的寬度，以設置寬度百分比的方式顯示在 progress bar。 觸發時點 播放 video/ audio 時，video/ audio 的播放位置改變時。 currentTime： currentTime 屬性 -&gt;讀取 video/ audio 的播放位置。 duration： duration 屬性返回當前 audio/ video 的長度，以秒計算。 progressPercent： 按照當前歌曲播放的進度佔總歌長的比例。 1234567// timeupdate event$('#audio').on('timeupdate', function() { const duration = $('#audio')[0].duration const currentTime = $('#audio')[0].currentTime const progressPercent = (currentTime / duration) * 100; $('#progress').css('width', `${progressPercent}%`) /*% 不要忘記*/}) tags: javascript","link":"/2021/01/20/JS%E7%B7%B4%E7%BF%92_%E9%9F%B3%E6%A8%82%E6%92%AD%E6%94%BE%E5%99%A8/"},{"title":"git 常用指令","text":"git v.s github 簡介與實作學習目標 什麼是 git 安裝 git git 常用指令 什麼是 github 認識 github，註冊 gitub 帳號 產生 ssh key 上傳到 github，讓 github 認識你的電腦 github 上創造一個 Repository（repo) 什麼是 github? 什麼是 git git 是個軟體 用 command line 操作 可以讓多個開發者一起開發協作 是個分散式版本控制系統， 讓你回到歷史紀錄的某一時刻 因為每次不論由 computerA 或 computerB 的提取及操作，都是將那個版本直接 copy 下來，所以只要任何一處協同工作用的伺服器發生故障，事後都可以用任何一個本地倉庫進行恢復。 圖文網址：https://kknews.cc/code/4vvmvv.html git 常用指令command line 常用指令傳送門 安裝 git 利用 mac 本身的開發者工具 點進去，輸入brew install git github 是個服務 可以上傳你的程式碼 註冊 gitub 帳號前往官網 註冊帳號 產生 ssh key 並上傳到 github首先在終端機先輸入cd(到 user 那) -&gt; pwd（確認是真的是 user) 先產生一個名為.ssh的資料夾，在終端機輸入mkdir .ssh 前往該資料夾，cd .ssh ssh-keygen -t rsa -C &quot;xxx@xxxxxx.com（自己的email）&quot;(產生自己的公鑰跟私鑰) 輸入cat id_rsa.pub(cat 公鑰，通常是把 cat 公鑰產生出來的碼貼到 github 上) 打開 github -&gt; setting -&gt; ssh key 把公鑰貼過來並給他一個名字 github 上創造一個 Repository（repo) 創造一個 repo點選上面的＋，選擇 new repository 輸入你的 repo 的名稱，可以選擇將這個公開與否） 回到 iterm 要是本地電腦 尚未有 專案資料夾選擇 creat a new repository on the command line操作 要是本地電腦已有專案資料夾 選擇 push an existing repository from the command line操作 tags: git","link":"/2020/11/08/git%20v.s%20github%E7%B0%A1%E4%BB%8B%E8%88%87%E5%AF%A6%E4%BD%9C/"},{"title":"git 常用指令","text":"git add 表示把檔案加入暫存區，交給 git 操控。 Ex. 要是我想把 abc.txt 這個檔案加到 git_demo 這個資料夾， 先 cd 到目的地資料夾，在輸入git add &quot;abc.txt&quot;就可以在用git status確認是否真的加入了 git commit 提交版本 當你不論對檔案做新增修改任何動作時，其實只是先將檔案放入暫存區，需要 git commit 後才是真正的將檔案提交至倉庫存放。 寫法：git commit -m &quot;提交版本的資訊&quot; 延續上一個 Ex. 我們新增了一個 abc.txt 檔案，接著我們輸入git add -m &quot;add abc.txt&quot; git push 推送更新遠端資料庫 將更新後的資料推送更新至遠端的 git 伺服器資料庫 延續上一個 Ex. 我們新增了一個 abc.txt 檔案，也將檔案提交至倉庫存放了，接著我們在網頁上的 github 創建了一個 repo(git_demo)，之後我們準備將檔案更新至 git 伺服器資料庫上。 前往 github 網頁創造一個 repo，假設 repo 名稱為 git_demo 回到 vscode 輸入git remote add origin git@github.com:Chrislinlin/git_demo.git 輸入 git push -u origin master 成功將 abc.txt 檔案推送給 github 上的遠端資料庫 git clone/pull取得 repo 使用時機：在 git 上看到有趣的專案，想要把他載到本地端電腦 探討 git clone/ git pull 使用時機 進入&lt;專案&gt;裡，點選 code，將連結複製起來 回到 iterm，先 cd 存放專案的目的地資料夾 輸入 git clone git@github.com:Chrislinlin/cinnamon.git 目的地資料夾已成功載入專案內容 git clone/ pull 差別 要是第一次看到有趣的專案要載下來，請用 git clone 要是第二次以上要 renew，請用 git pull git rm 刪除檔案 寫法： git rm '要刪掉的檔案' ex. 我們要將 abc.txt 這個檔案給刪掉。 cd 到目的地資料夾後輸入 git rm abc.txt git mv 修改檔案名字 寫法： git mv '舊名字' '新名字' ex. 我們要將 abc.txt 名字改成 def.txt。cd 到目的地資料夾後輸入 git mv abc.txt def.txt 檔案名字就從 abc -&gt; def git merge git branch查看/ 創造分支 查看分支 寫法：git branch &quot;分支名稱&quot; 創造分支 寫法：git branch &quot;分支名稱&quot; ex. 先輸入 git branch 查看目前有什麼分支 目前只有 master 這個分支 輸入git branch newDemo創造一個 newDemo 的分支在用git branch查看，確定分支已被創造 git checkout 切換分支 寫法： git checkout '要切換的分支' ex. 從 master 分支 要切換為 newDemo 分支 輸入 git checkout newDemo就轉換成功了。 ==組合技== 寫法：git checkout -b&quot;要創造的branch這個方式直接把git branch + git checkout加在一起，可以直接在 A 分支，立刻創造 B 分支並切換到那去。 tags: git","link":"/2020/11/07/git%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"title":"Hexo 筆記一","text":"hexo 系統是採用以 md 檔發佈至部落格， 安裝步驟 確認電腦已安裝 node.js git 使用 npm 下載 hexo 1$ npm install hexo-cli -g npm 是什麼？npm 為 Node Package Manager 的縮寫，開發者可以透過 Node 隨 附的 npm cli，進行套件的安裝及管理。 初始化資料夾(假設以blog作為資料夾名稱命名) hexo 初始化 進入該資料夾(blog) npm install 12345$ hexo init$ cd blog$ npm install 安裝完成使用 vscode 打開，左邊應該會出現如下圖所示，請忽略 icarus 及 landscape 主題，這是我之後去安裝的，預設只有config.yml 使用本地端開啟部落格網頁在 terminal 輸入指令 1$ hexo server //可以縮寫 hexo s 發布文章 下載 Markdown 檔 先到 hackMD，把之前已寫好的筆記下載至本地端(hackMD 是個可以線上操作記錄筆記網站，也可將筆記檔(.md 檔)下載至本地端) 下載方式如下: 在本地端在 blog 資料夾內層中找到_posts 資料夾，並將.md 檔案拖曳至於其中 輸入hexo g || hexo generate 接著輸入 hexo s || hexo sever 使狀態回到 localhost:4000，預覽部落格的狀態 再輸入 hexo d || hexo deploy 刪除文章 進入本地端存放 md 檔的資料夾source / _post 中，找到欲刪除的文件，在本地直接執行刪除。然后依次執行指令 12hexo ghexo d 再去主頁查看，就會發現发现部落格上你所要刪除的文章已消失無蹤了。 tags: Hexo","link":"/2021/04/02/Hexo%20%E7%AD%86%E8%A8%98%E4%B8%80/"},{"title":"Hexo 筆記二","text":"常用指令hexo g產生靜態檔案，會於目錄下產生 public 資料夾。 1$ hexo generate || hexo g hexo s啟動伺服器，預設是 http://localhost:4000/。 1$ hexo server || hexo s hexo d部署網站。（ 比如把網頁推上 github 平台） 1$ hexo deploy || hexo d ==超常用縮寫组合== 123$ hexo d -g 產生靜態檔後部署$ hexo s -g 產生靜態檔後預覽 端口被佔用 出現的錯誤訊息代表端口 4000 port 被佔用了，所以無法以hexo server去顯示部落格。 解決方法 找到對應的端口 1sudo lsof -i:port # port為對應的端口 我們知道端口是被 PID 10247 所佔領 把佔領的 PID 殺了 1sudo kill -9 10247 #上面顯示的PID 即可成功執行 hexo server 1hexo server hexo 資料同步其他台電腦就算有把原本在 a 電腦的全部 hexo 資料，複製到 b 電腦，在 b 電腦也無法執行 hexo 解決方法 確認另外一台電腦有沒有安裝 npm 輸入指令 1npm install hexo-cli -g tags: Hexo","link":"/2021/04/02/Hexo%20%E7%AD%86%E8%A8%98%E4%BA%8C/"},{"title":"Hexo 筆記三","text":"推上 github 先在 github 新增一個 repository，命名邏輯為 12github ID名稱.github.io例：Chrislinlin.github.io 複製該 repository 的網址(例：git@github.com:Chrislinlin/Chrislinlin.github.io.git) 用 vscode 編譯器，打開_config.yml 檔案，修改deployment的部分 1234deploy: type: git repo: https://github.com/Chrislinlin/Chrislinlin.github.io branch: main 安裝 git 部署套件 1$ npm install hexo-deployer-git --save 輸入指令，將網站佈署到伺服器上 1$ hexo deploy -g 設定 repository 的主題在 github 的該 repository 頁面，進入「setting」往下滑，點按「change theme」 在瀏覽器中查看網址，成功的看到部落格推上去！https://Chrislinlin.github.io/ 若有檔案更新，則重複輸入指令 1hexo deploy -g 更換主題 尋找前往hexo 主題官網尋找有興趣的主題 安裝 前往該主題的 github 頁面，勇敢的 git clone 他，這裡示範安裝 icarus 主題 在 vscode 開啟當初創建部落格資料，輸入指令 clone 想要安裝的主題 1git clone https://github.com/ppoffice/hexo-theme-icarus.git 修改_config.yml原本內建的主題是landscape，這裡修改為 icarus 重新產生專案 1hexo g 完成 tags: Hexo","link":"/2021/04/02/Hexo%E7%AD%86%E8%A8%98%E4%B8%89/"},{"title":"Pseodo Code(虛擬碼)","text":"它以程式語言的書寫形式指明演算法的職能。相比於程式語言（例如 Java、C++、C、Delphi 等等）它更類似自然語言。它是半形式化、不標準的語言。我們可以將整個演算法執行過程的結構用接近自然語言的形式（這裡可以使用任何一種作者熟悉的文字，例如中文、英文，重點是將程式的意思表達出來）描述出來。使用虛擬碼，可以幫助我們更好的表述演算法，不用拘泥於具體的實現。維基小科普 思考步驟 先腦袋想一下這個大問題，將大問題分割成很多個小問題 一行只做一件事 善用敘述、條件判斷 要是有需要重複執行的情況，利用跳轉（jump）來實現重複執行 練習wordLength()得到字串長度的 wordLength() 函式 預期 pen 的字串長度為 3 預期 apple 的字串長度為 5 預期 Pineapple 的字串長度為 9 預期 古坂大魔王 的字串長度為 5 123456- PseudoCode :1. 宣告 input 為 要輸入的單字 // 設置初始條件2. 建造 func wordLength(input): //建立測試函式，決定回傳值 得到 input.length;3. wordlength(input);//執行函式 LowerCase()將單字變成小寫 wordLowerCase() 函式 5) 預期大寫的喵變成小寫的喵 CAT 變成 cat 6) 預期 Tea 變成 tea 123456- PseudoCode :1. 宣告 input 為 要輸入的單字 // 設置初始條件2. 建造 func wordLowerCase(input): //建立測試函式，決定回傳值 得到 input ← lower(input)3. wordLowerCase(input)//執行函式 UpperCase()將單字變成大寫 wordUpperCase() 函式 7) 預期 Dog 變成 DOG 8) 預期 hello world 變成 HELLO WOLRD 123456- PseudoCode :1. 宣告 input 為 要輸入的單字 // 設置初始條件2. 建造 func wordLowerCase(input): //建立測試函式，決定回傳值 得到 input ← Upper(input)3. wordUpperCase(input)//執行函式 getLastCharacter()取得最後一個字元 getLastCharacter() 函式 預期 Pen 的最後一個字元為 n 預期 Pencil 的最後一個字元為 l 預期 Monday 的最後一個字元為 y 12345- PseudoCode :1. 宣告 input 為 要輸入的string // 設置初始條件2. 宣吿得到input string的長度;3. 將字串變成一個個字符，利用索引值取出4. 放入index.html tags: pseudocode","link":"/2021/04/03/Pseodo%20Code(%E8%99%9B%E6%93%AC%E7%A2%BC)/"},{"title":"W3C DOM 簡介","text":"DOM 是什麼？ DOM 是 Document Object Model 的縮寫 是一個文件樹 W3C 當初為解決各大瀏覽器間物件標準不一致時，所制定的一個新的標準物件模型，在這標準下，一個物件所有的標籤定義，包含每一個文字，都是一個物件，這些物件會組成一個樹狀結構。 例子： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM World&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello!World!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 圖片來源 文件從根元素開始，包含許多子元素。 文件上的標籤元素或是文字都是文件樹上的一個==節點==(Node 的物件) 常見的節點型態有許多種，某些特定的節點物件是哪一種節點會紀錄在該節點物件的 nodeType 屬性 文件物件的方法文件可以動態產生節點 document.creatElement(tagName) 建立一個標籤名成為 tagName 的元素 如：document.createElement(‘div’); document.creatTextElement(text) 建立一個文字的節點 如：document.creatTextElement(‘Hello, World!’);` 文件屬性 屬性名稱 說明 childNodes 傳回目前元素所有子節點的節點清單 firstChild 傳回目前元素的第一個子節點 lastChild 傳回目前元素的最後一個子節點 nextSibling 傳回緊鄰目前元素 後 的節點 presviousSibling 傳回緊鄰目前元素 前 的節點 parentChild 傳回元素的父節點 nodeName 傳回節點的名稱 nodeType 傳回節點的型態 nodeValue 傳回節點的值 節點方法 node.appendChild(childNode) 將指定的子節點附加在 node 的子節點清單的最後面 如：div.appendChild(span); node.removeChild(childNode) 將指定的子節點從 node 中刪除 如：div.removeChild(span); node.replaceChild(Anode, Bnode) 將 node 子節點中，把 b 節點換成 a 節點 如：div.replaceChild(aSpan, bSpan); node.hasChildNodes() 判斷是否有子節點 如：div.hasChildNodes(); 元素物件節點方法 element.getAttribute(attributeName) 取得元素中，某屬性的值 如：div.getAttribute(“class”); element.setAttribute(attributeName, value) 設定元素中，某屬性的值 如：div.setAttribute(“class”,”item”); element.removeAttribute(attributeName) 設定元素中，某屬性的值 如：div.removeAttribute(“item”); element.getElementByTagName(tagName) 取得元素中名稱為 tagName 的所有子元素 如：div.getElementByTagName(tagName); tags: javascript","link":"/2021/04/03/W3C%20DOM%20%E7%B0%A1%E4%BB%8B/"},{"title":"bootstrap","text":"由 HTML、CSS 和 JavaScript 寫成的前端框架，設計核心為達成 RWD 響應式頁面，也就是讓你的網站可以自動排版，目前已出到 bootstrap 5，。 導入 在 css 裡貼上 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&gt; 在 javascript 裡貼上 1&lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js&quot; integrity=&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; 當然你也是可以把版本載到本機下來用連結的 通用格式有時候我們把很多個 bootstrap 樣版貼上來，但大家都會黏在一起，當又懶得去設定個別的 css 時，可以使用 bootstrap 內建的 css 設定去調整不同元素的空間距離及顏色呈現。 Spacing 使用在 css 熟悉的margin及padding 123456789m：marginp：paddingt：topr：rightb：bottoml：leftw: widthx：-right和-lefty：-top 和 -bottom 組合技 12345678910111213141516m：marginmt：margin-topmr：margin-rightmb：margin-bottomml：margin-leftmx：margin-right 和 margin-leftmy：margin-top 和 margin-bottomp：paddingpt：padding-toppr：padding-rightpb：padding-bottompl：padding-leftpx：padding-right 和 padding-leftpy：padding-top 和 padding-bottomw-100: width:100% 數字bootstrap 數字代表間距的意思。數字 1 代表 0.25rem 而 1rem = 16pxmb-5 = margin-bottom: 3rem(48px) 起手式-建置隔線系統123456789101112131415161718192021&lt;!---隔線系統容器--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;!---資料容器--&gt; &lt;div class=&quot;text&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit, amet consectetur laudantium. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;!---資料容器--&gt; &lt;div class=&quot;text&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit, amet consectetur laudantium.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 建立一個容器container，在要執行的內容都丟到容器裡 container 容器有分二： 固寬容器：固定寬度的容器，內建在不同裝置下他會有不同的寬度&lt;div class =&quot;container&quot;&gt; 非固定寬度容器（滿版）：&lt;div class =&quot;container-fluid&quot;&gt;滿版 在這 container 容器裡，再建立一個 row 容器 &lt;div=&quot;row&quot;&gt; row容器裡，設定需要的欄位數。在 row 裡在加入名為 col-(斷點代碼)-(格數) 的 class 來進行，例如媒體寬度在 ≥768px 時，格數要佔 3 格時則寫 col-md-3。 Bootstrap 所預設的格線數為 12，把一行 row 分成 12 等份，依照想要的寬度去決定尺寸代號，分幾等分。 尺寸代碼： Small — sm 576px &lt;= 768px Medium — md 768px &lt;= 992px Large — lg 992px &lt;= 1200px Extra large — xl 1200px&lt;= 例子：要是我們想要把畫面做 RWD 效果時，像是使用螢幕有螢幕的顯示方式，使用平版有平板的及手機有手機的尺寸方式。可以直接添加不同的欄位名稱，並在最後一個欄位新增斷點資訊。&lt;div class =&quot;col-12 col-md-6&quot;&gt; 建立隔線系統有三種 自動隔線系統：使用col，無法折行，假如要改變拆行必須在 row。要是想分五欄的版面就直接 12345678910111213&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;...&lt;/div&gt;&lt;/div&gt;### form-select- 成品![](https://i.imgur.com/MB1YLZW.png) Open this select menu 台北市 桃園市 新竹市 12345678910111213- ·`selected` 一開始預設的選擇- 資料帶入是帶入1 兒不是one### form-上傳選單- 成品 ![](https://i.imgur.com/0aZg7ER.png)```.html &lt;div class=&quot;input-group mt-5&quot;&gt; &lt;label class=&quot;input-group-text&quot; for=&quot;inputGroupFile01&quot;&gt;Upload&lt;/label&gt; &lt;input type=&quot;file&quot; class=&quot;form-control&quot; id=&quot;inputGroupFile01&quot;&gt; &lt;/div&gt; label裡的 for 屬性，一定要跟 input 裡的 id 一致不然會失敗。 Utility-Overflow把超過容器的範圍做隱藏或是顯示或是出現轉軸 1234&lt;div class=&quot;overflow-auto&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;overflow-hidden&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;overflow-visible&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;overflow-scroll&quot;&gt;...&lt;/div&gt; navbar+card 成品 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Navbar&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-bs-toggle=&quot;collapse&quot; data-bs-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt; &lt;ul class=&quot;navbar-nav me-auto mb-2 mb-lg-0&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link active&quot; aria-current=&quot;page&quot; href=&quot;#&quot;&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item dropdown&quot;&gt; &lt;a class=&quot;nav-link dropdown-toggle&quot; href=&quot;#&quot; id=&quot;navbarDropdown&quot; role=&quot;button&quot; data-bs-toggle=&quot;dropdown&quot; aria-expanded=&quot;false&quot;&gt; Dropdown &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;navbarDropdown&quot;&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;hr class=&quot;dropdown-divider&quot;&gt; &lt;/li&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link disabled&quot; href=&quot;#&quot; tabindex=&quot;-1&quot; aria-disabled=&quot;true&quot;&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;d-flex&quot;&gt; &lt;input class=&quot;form-control me-2&quot; type=&quot;search&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot;&gt; &lt;button class=&quot;btn btn-outline-success&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div class=&quot;container mt-5&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Special title treatment&lt;/h5&gt; &lt;p class=&quot;card-text&quot;&gt;With supporting text below as a natural lead-in to additional content.&lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Go somewhere&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Special title treatment&lt;/h5&gt; &lt;p class=&quot;card-text&quot;&gt;With supporting text below as a natural lead-in to additional content.&lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Go somewhere&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Special title treatment&lt;/h5&gt; &lt;p class=&quot;card-text&quot;&gt;With supporting text below as a natural lead-in to additional content.&lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Go somewhere&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; tags: bootstrap","link":"/2021/04/01/bootstrap/"},{"title":"JS_web storage","text":"介紹兩種 web storage 的儲存方式。 型態： localStorage 可以跨瀏覽器分頁做使用、使用者關掉分頁或瀏覽器再打開資料仍不會消失，且資料無期效限制，資料將永久被保留 sessionStorage 當使用者關掉瀏覽器或分頁時，sessionStorage 中的資料將被清空。 資料儲存格式 以 JSON 的 key-value 格式儲存 方式 存入資料 ===setItem()=== 12localStroage.setItem(key, valuesessionStroage.setItem(key, value) 取出資料 ===getItem()=== 1234localStroage.getItem(key, valuesessionStroage.getItem(key, value) 移除資料 ===removeItem()=== 12localStroage.removeItem(key, valuesessionStroage.removeItem(key, value) 找到儲存的資料 console 資料出來後，去開發者工具的 Application 中查看 local Storage。 缺點 儲存容量只有 5mb key-value 只接受==字串== 解決方法：轉換成 JSON 格式的字串 透過JSON.stringify()先轉換成字串，要取出資料時再透過 JSON.parse() 將資料轉換為原本的格式。 tags: javascript","link":"/2021/03/29/JS_web%20storage/"},{"title":"CSS_Note","text":"對於 css 中一些屬性的筆記如下(持續增加中…)。 weight:100% 若沒有給預設值，會自動填滿整個瀏覽器的頁面寬 height:100% 沒有預設值，沒寫就是 null height 的百分比值需要父元素有一個有效的高度值才能起作用-ex.12height: 100%; margin: 0; padding: 0;} box-sizing：border-box 讓你不用手動加減就可以涵蓋 padding+margin 在原本容器尺寸 background-image 插入背景圖片 linear-gradient 漸層 background: linear-gradient(方向/角度, 顏色1 位置(％數), 顏色2 位置(％數)....);) 要是方向沒寫的話，預設為由上往下，若填寫角度則由左下角為圓心順時針旋轉 ex. 1linear-gradient(blue, yellow 30%, blue 90%) position 定位 absolute(絕對定位) 使用absolute屬性定位的元素是以在他所處==上層容器==的相對位置，若沒有上層容器，則以body(螢幕左上角)位置作為相對位置 當畫面在捲動時，有該屬性的元素還是會隨著頁面捲動。 fixed(固定定位) 相對於瀏覽器視窗來定位，即便頁面捲動，它還是會固定在相同的位置。 relative(相對定位) 會使其元素「相對地」調整其原本該出現的所在位置，做出調整。 例子，假設設定兩個帶有顏色的容器， 若增加relative屬性後且給定距原本元素的距離後。 font-weight(文字體粗細)Demo 傳送門 line-height text 裡的行高 transition 動畫 opacity .5s .5s //延長多久 delay 多久 常見屬性 transition-delay transition-duration transition-property transition-timing-function 可以跟 transform 一起搭配 例子假設 html 有一個容器，我們在 css 設定他碰到時容器會以 2 秒時間增長程式碼如下。 123456789div { width: 100px; height: 100px; background: red; transition: width 2s;}div:hover { width: 300px;} transform 2D/3d transform 常見屬性： translate 以原本容器所在處，往 X 或 Y 軸移動， scaleX/scaleY() rotate(角度) 讓容器原地旋轉多少角度，若角度值為負數，則逆時間旋轉，要是角度為負責代表逆時鐘旋轉。 transform:translate z-index 層 只有在設定 position 的元素上會有效 設定值越高越前面，值可以為負數 檢查 被覆蓋的層(想要置頂的層）的 position 是否也為 relative 或者 absolute 如果 1 成立，則判斷是否此層的 z-index 比誤覆蓋的層的 z-index 數值大 如果 2 成立，判斷是否此層的父級元素比誤覆蓋的層的 z-index 數值大 如果 3 成立，判斷是否此層的父級元素比誤覆蓋的層的父級層的 z-index 數值大 overflow 元素要是超出某一範圍時該怎麼辦 常見的值 overflow:auto; //預設會自動使用捲軸 overflow:visible; //顯示的文字或圖片會直接超出範圍，不使用捲軸。 overflow:hidden; //自動隱藏超出的文字或圖片。 overflow:scroll; //自動產生捲軸。 overflow:inherit; //繼承自父元素的可見性。 css 選擇器- 子選擇器(選擇器之間使用&gt;大於符號)選擇父元素的子元素，但不包括子元素的子元素 12&lt;div class=&quot;div1&quot;&gt;&lt;p&gt;div1-P1&lt;/p&gt;&lt;span&gt;&lt;p&gt;div1-P2&lt;/p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt;&lt;p&gt;div2-P1&lt;/p&gt;&lt;span&gt;&lt;p&gt;div2-P2&lt;/p&gt;&lt;/span&gt;&lt;/div&gt; 123456.div1 &gt; p { color: #F00;}.div2 p { color: #F00;} tags: css","link":"/2020/12/02/CSS%20Note/"},{"title":"JS_練習_Github搜尋器","text":"透過串接製作一個github REST API搜尋器，輸入 github 用戶帳號或是 repo 名稱可以列表將使用者專案數、所屬公司列表追蹤人數列表出來，若是搜尋不到則會觸發告警提示。 成品畫面 功能 呈現使用者資訊(如:大頭照所屬公司專案數目何時加入…. 若搜尋不到輸入資訊，出現告警提示 顯示使用者最新的 repo 在下方，可以透過點擊連結相關網頁 HTML/CSS主要透過 bootStrap 已設定好的樣式呈現。 JSgetUserData()利用ajax串接 API，確認串接網址/資料型態/方式/成功或失敗獲得我們想要的資訊，並在前面取得資料時要是載入錯誤，則會觸發 error 函式，最後呼叫函式顯示在頁面上。 成功：會取得 GitHub 用戶資訊並呼叫showProfile()將取得內容當做函式參數。 失敗：會呼叫showAlert()利用alert alert-danger 的 class 讓其顯示為紅色。 123456789101112131415161718192021222324252627282930function getUserData(){ $.ajax({ //github endpoint url: `https://api.github.com/users/${userName}`, method: 'GET', dataType: 'json', success: function(res) { let obj = {}; obj.avatar_url = res.avatar_url !== null ? res.avatar_url : ''; obj.name = res.name !== null ? res.name : ''; obj.html_url = res.html_url !== null ? res.html_url : ''; obj.public_repos = res.public_repos !== null ? res.public_repos : ''; obj.public_gists = res.public_gists !== null ? res.public_gists : ''; obj.followers = res.followers !== null ? res.followers : ''; obj.following = res.following !== null ? res.following : ''; obj.company = res.company !== null ? res.company : ''; obj.blog = res.blog !== null ? res.blog : ''; obj.location = res.location !== null ? res.location : ''; obj.created_at = res.created_at.substr(0, 10) !== null ? res.created_at.substr(0, 10) : ''; obj.updated_at = res.updated_at.substr(0, 10) !== null ? res.updated_at.substr(0, 10) : ''; showProfile(obj); }, error: function(res) { data = res.responseJSON.message; if (data === 'Not Found') { showAlert(data, 'alert alert-danger'); } } }); getRepoData()同樣利用ajax串接 API，確認連結位置，決定資料型態，取得資料，並在連結成功時，呼叫函式showRepo函式。url 裡的連結網址有設定per_page=5，讓展現搜尋資料時，只會出現五筆資料。 1234567891011function getRepoData(){ $.ajax({ url:`https://api.github.com/users/${userName}/repos?per_page=5&amp;sort=created: asc`, method:'GET', datatype:'json', success: function(data){ getData = data; showRepo(getData); } })} showProfile()在一開始getUserData函式中設定呼叫showProfile()函式，將得到的使用者資料寫入選取容器的 html 裡。 123456789101112131415161718192021222324252627282930313233function showProfile(user){$('#profile').html( `&lt;div class=&quot;card card-body border-0&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;img src=&quot;${user.avatar_url}&quot; class=&quot;img-fluid rounded-circle mb-2&quot;&gt; &lt;h5 class=&quot;mt-2 text-center&quot;&gt;${user.name}&lt;/h5&gt; &lt;a href=&quot;${user.html_url}&quot; target=&quot;_blank&quot; class = &quot;btn btn-primary btn-block mb-4&quot;&gt;View Profile&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-md-9&quot;&gt; &lt;div class=&quot;container mt-2 px-0&quot;&gt; &lt;span class=&quot;badge badge-primary ml-5&quot;&gt;Public Repos: ${user.public_repos}&lt;/span&gt; &lt;span class=&quot;badge badge-secondary&quot;&gt;Public Gists: ${user.public_gists}&lt;/span&gt; &lt;span class=&quot;badge badge-success&quot;&gt;Followers: ${user.followers}&lt;/span&gt; &lt;span class=&quot;badge badge-info&quot;&gt;Following: ${user.following}&lt;/span&gt; &lt;/div&gt; &lt;ul class=&quot;list-group list-group-flush mt-2 ml-5&quot;&gt; &lt;li class=&quot;list-group-item&quot;&gt;Company: ${user.company}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Website/Blog: ${user.blog}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Location: ${user.location}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Member Since: ${user.created_at}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Currently Updated: ${user.updated_at}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;col-md-12&quot;&gt; &lt;h3 class=&quot;page-heading mb-3&quot;&gt;Latest Repos&lt;/h3&gt; &lt;div id=&quot;repos&quot;&gt;&lt;/div&gt;&lt;/div&gt;`)} showRepo()把取得資料利用forEach方式加入至創建好的容器repo裡，並決定其 html 外觀樣式。 1234567891011121314151617181920212223//show repofunction showRepo(repos){ repos.forEach(function(repo){ //把repodata東西加在getRepoData中創建的容器後 const repoData = $('&lt;div class = &quot;card card-body mb-2 border-0&quot;&gt;&lt;/div&gt;').appendTo('#repos'); let repoDes = repo.description !== null ? repo.description : ''; repoData.html(` &lt;div class=&quot;row shadow-sm p-3 bg-white rounded&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;a href=&quot;${repo.html_url}&quot; target=&quot;_blank&quot;&gt; &lt;h3&gt;${repo.name}&lt;/h3&gt; &lt;/a&gt; &lt;p&gt;${repoDes}&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;span class=&quot;badge badge-warning m-1&quot;&gt;Stars ${repo.stargazers_count}&lt;/span&gt; &lt;span class=&quot;badge badge-success m-1&quot;&gt;Watchers ${repo.watchers_count}&lt;/span&gt; &lt;span class=&quot;badge badge-info m-1&quot;&gt;Forks ${repo.forks_count}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; `)} );} showAlert()當使用者輸入資訊在 GitHub 網站找不到時，會秀出紅色示警視窗，並經過設定時間五秒後示警視窗消失。創立變數 alertMessage，設定其元素、屬性及其內容，使用insertBefore在 alertMessage==前==再加上 bootstrap 設定好的屬性，並將搜尋結果欄清空。 1234567891011121314//showalert functionfunction showAlert(message, className){ const alertMessage = $('&lt;div&gt;&lt;/div&gt;').attr('class', className + ' text-center'); alertMessage.text(`User &quot;${userName}&quot; is ${message}`) //insertBefore在現有的子節點前插入一個新的子節點 alertMessage.insertBefore($('.search.card.card-body.border-0')) $('#profile').html(''); //setTimeout 2秒後把alertMessage移開 setTimeout(function(){ alertMessage.remove() },5000)} click event透過在選取的searchBtn點擊後觸發函式，給定 userName 當作參數。 12345678const searchBtn = $('.search-btn');searchBtn.click(function(){ //指定searchUser 的val 給username userName = searchUser.val(); getUserData(userName); getRepoData(userName); searchUser.val('');}) tags: javascript","link":"/2021/02/18/JS%E7%B7%B4%E7%BF%92_Github%E6%90%9C%E5%B0%8B%E5%99%A8/"},{"title":"JS_練習_可排序表單","text":"能夠將電腦亂排順序的名單，自由選取排列，排列正確會變綠色，順序錯誤會是紅色。 純 HTML 畫面 成品畫面 HTML再 HTML 建立空白的無序列表，等 JS 再將內容加至設定好的ul，最後再加上一個button以執行 JS 已確認排序是否正確。 1234567891011&lt;h1&gt;Top 10 Videos on Youtube 2020&lt;/h1&gt;&lt;p&gt;Drag and Drop items into their corresponding spots&lt;/p&gt;&lt;ul class=&quot;draggable-list&quot; id=&quot;draggable-list&quot;&gt;&lt;/ul&gt;&lt;button class=&quot;check-btn&quot; id=&quot;check-btn&quot;&gt; Check Order &lt;i class=&quot;fas fa-paper-plane&quot;&gt;&lt;/i&gt;&lt;/button&gt; CSSbody::after在根元素body後面，透過偽元素選擇器，使整個 body 加上一層半透明的黑影，使畫面看起來質感加分。 123456789body::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); } 偽類常見的偽類樣式： :active:滑鼠按下會產生的狀態。 :focus:鍵盤聚焦會產生的狀態。 :hover:滑鼠滑過會產生的狀態。 :link:還沒訪過會產生的狀態。 :visited:被訪過會產生的狀態。 JS實現步驟 創造一個陣列放入容器，陣列是有索引值與內容。 利用 sort 方法將隨機產生的索引值按照大小排列， Drag and Drog API 創造要丟進 DOM 的陣列 123456789101112- const hottestVideo = [ '羅一鈞副組長', '蔡阿嘎與孕婦二伯', '粿粿-花蓮落下事件', '這群人-請假經典語錄', '黃氏兄弟-我想跟家人說', '中指通的歐美女優精選', '孫生去監獄看媽媽', '狠愛演-謝謝大家', '反正我很閒-卑鄙源之助的一天', '東森51-臨終前最後26秒奮力道別'] creatList() 利用...將陣列展開變成個別的值。 利用forEach()將每個陣列的值，都放到 li 裡，並設定 li 裡的屬性及加上索引值。 填入 HTML 的內容在我們所定義好屬性的陣列裡。 part II: 利用map()方法創造新陣列。回傳 該影片的 value 創造一個 sort，並用Math.random方法隨機產生 0~1 的數字 part III: 利用 sort 方法將 random 出來的數字按照大小排列。 part IV: 再利用 map 方法將我們 part II 產生的 valuesort()小科普 123456789101112131415161718192021222324252627282930313233creatList()//creat List items into DOMfunction creatList(){ [...hottestVideo] //part II .map(function(a){ return{ value:a , sort: Math.random() } })//part III .sort(function(a,b){ return (a.sort - b.sort) })//part IV .map(function(a){ return a.value }) .forEach(function(video,index) { const listItem = document.createElement('li'); //index =0~9 listItem.setAttribute('data-index', index); listItem.innerHTML = ` &lt;span class ='number'&gt;${ index + 1 }&lt;/span&gt; &lt;div class =&quot;draggable&quot; draggable =&quot;true&quot;&gt; &lt;p class =&quot;video-name&quot;&gt;${video}&lt;/p&gt; &lt;i class = &quot;fas fa-grip-lines&gt;&lt;/i&gt; &lt;/div&gt; `; listItems.push(listItem); draggableList.appendChild(listItem); });} 函式外呼叫函式，畫面呈現。 加入 partII/ part III 加入 part IV addEventListener() drag event 小科普 設定 ==drag==事件，其中分為兩項觸發 被選擇的物件。 dragstart 方法就是在物件開始拖曳時觸發。 在觸發事件時利用closest()方法取得當前元素最近得祖先元素，並透過getAttribute得到該元素的indexclosest()小科普 可以當作目標的物件。 dragleave 是當被選擇物件被拖曳到可以當作目標物件的上方時，在離開目標物件上方時，瞬間觸發。 dragover 當被選擇物件被拖曳到可以當目標物件上方時觸發。是目標物件觸發！不是被選擇物件。 drop 當被選擇物件被拖曳到目標物件時觸發。是目標物件觸發！不是被選擇物件。 建立函式swapItem()，利用最上面先建立一個空陣列 listitems。再設立參數並將值選出且利用appendChild賦值，將內容進行交換。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 addEventListeners() });}function dragStart() { // console.log('event: ' , 'drapstart') dragStartIndex = this.closest('li').getAttribute('data-index'); // console.log(dragStartIndex); } function dragOver() { console.log('event: ' , 'drapover') } function dragDrop() { // console.log('event: ' , 'drapDrop') const dragEndIndex = +this.getAttribute('data-index') swapItems(dragStartIndex, dragEndIndex); this.classList.remove('over'); } function swapItems(fromIndex, toIndex){ // console.log(124); const itemOne = listItems[fromIndex].querySelector('.draggable') const itemTwo = listItems[toIndex].querySelector('.draggable'); // console.log(itemOne, itemTwo); listItems[fromIndex].appendChild(itemTwo); listItems[toIndex].appendChild(itemOne); } function dragLeave() { console.log('event: ' , 'dragleave') } function dragEnter() { console.log('event: ' , 'dragenter') }function addEventListeners(){ const draggables = document.querySelectorAll('.draggable') const dragListItems = document.querySelectorAll('.draggable-list li') draggables.forEach(function(draggable){ draggable.addEventListener('dragstart', dragStart); }); dragListItems.forEach(function (item) { item.addEventListener('dragover', dragOver); item.addEventListener('drop', dragDrop); item.addEventListener('dragenter', dragEnter); item.addEventListener('dragleave', dragLeave); });} click event將 HTML 所設定的 button，綁定一個click事件，呼叫checkOrder函式。 checkOrder()由於上面有設定 random 公式，當畫面 reload 時，是隨機排列的。我們將列表重新排序時，最後點下 btn，確認是否排列正確。設定變數videoName取得 listItem 裡的文字，將videoName跟原先設定好的listItem[]裡相同位置的文字進行比對。若不相同 ＝&gt;加上屬性 wrong若相同 ＝&gt;移除屬性 wrong增加屬性right 123456789101112131415$('#check-btn').click(checkOrder);function checkOrder(){ listItems.forEach(function(listItem, index){ const videoName = listItem.querySelector('.draggable').innerText.trim(); // console.log(videoName) if(videoName !== hottestVideo[index]){ listItem.classList.add('wrong'); }else{ listItem.classList.remove('wrong'); listItem.classList.add('right'); } })} tags: javascript","link":"/2021/01/28/JS%E7%B7%B4%E7%BF%92_%E5%8F%AF%E6%8E%92%E5%BA%8F%E8%A1%A8%E5%96%AE/"},{"title":"JS練習_登入頁面","text":"製作一個登入頁面，讓使用者得以輸入個人資訊，並設定輸入條件，像是： 功能 若使用者尚未輸入任何資訊或是輸入條件不符，輸入欄出現警示紅框 在信箱部分只能輸入信箱資料 在使用者名稱或密碼設定輸入字數條件 HTML 可以使用 vscode 快捷鍵 cmd +d 選取下一個相同的字。 使用 bootstraps 設定容器，使容器可以隨著螢幕伸縮改變，呈現 RWD 的效果 CSS visibility 屬性： visable : 產生的 box 是可見的 none : 產生的 box 是不可見的讓元素/物件隱藏起來 與 display:none 最大差別是，D-N 是整個屬性關閉 :root 使用：root 設定顏色變數，在做顏色調用時可以直接輸入變數取用 12345678:root{ --success-color:#2ecc71; --error-color: #e74c3c;}/*----取用時----*/h1{color: var(--success-color)} JS 先宣告變數，利用 getElementById 取得元素 加入 Eventlistener 事件監聽 註冊一個submit事件，這邊的e.preventDefault();是用來停止預設的 submit 這個行為： 1234// Eventlistenerform.addEventListener('submit', function(e) { //註冊事件 e.preventDefault(); //停止預設行為}) 並在事件裡導入判斷函式 showSuccess()/ showError() showError 功能 當輸入條件不符合時，設定的 tag &lt;small&gt;會顯示出錯誤訊息 利用元素.className 方法，加入form-group error屬性，帶入 css，使輸入匡變成紅色。 showSuccess 功能 沒有錯誤訊息，將 class 名稱改成form-group success來讓 css 可以正確將輸入框顯示綠色。 checkRequired 功能getFieldName返回將輸入的 id 資訊，第一個字母變成大寫。 - charAt(0)回傳第０個值，再加上後面的小寫字元 - slice([begin, end])回傳陣列，可選澤從開始到結束的值。 判斷判斷式是否輸入正確，將輸入的陣列資訊每個值透過forEach讀取，再利用trim()方法，將空白字串去除 123456789101112131415// Get fieldnamefunction getFieldName(input) { return input.id.charAt(0).toUpperCase() + input.id.slice(1);}// Check required fieldsfunction checkRequired(inputArr) { inputArr.forEach(function(input) { if(input.value.trim() === ''){ showError(input, `${getFieldName(input)} is required`); } else { showSuccess(input); } });} Email 格式驗證 透過別人寫好的 emial 驗證函式，直接帶入驗證，並加入 if 迴圈，設定不同情況所執行不同的 showError() 123456789function isValidEmail(input) { const re = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // return re.test(String(email).toLowerCase()); if(re.test(input.value.trim())) { showSuccess(input); } else { showError(input, 'Email is not valid'); }} 調整驗證機制原本一開始是設定 submit 事件，並在 function 帶入多項 if 迴圈判斷，但這樣顯得整個程式碼繁雜。可以透過導入設定好的判斷函式，簡化程式碼。 1234567891011form.addEventListener('keyup',function(e){ e.preventDefault(); checkRequired([username, email, password, password2]); checkLength(username, 3, 15); checkLength(password, 8, 16); isValidEmail(email); if(!checkRequired([password, password2])){ checkLength(password, 8, 16); checkPasswordMatch(password, password2); }}) 並已將 function checkLength/checkRequired/ isValidEmail 設定好在上面 checkLength 帶入三個參數，分別為 input, min, max，利用條件判斷要是input小於 或是 大於設定條件，就會帶入 showError()函式，否則就會導入成功函式 ‵‵或是${}是 E6 的新語法，可以在裡面放置變數 123456789function checkLength(input, min, max) { if(input.value.length &lt; min) { showError(input, `${getFieldName(input)} must be at least ${min} characters`); } else if (input.value.length &gt; max) { showError(input, `${getFieldName(input)} must be less than ${max} characters`); } else { showSuccess(input); }} tags: js_練習","link":"/2020/11/29/JS%E7%B7%B4%E7%BF%92_%E7%99%BB%E5%85%A5%E9%A0%81%E9%9D%A2/"},{"title":"JS_練習_終極密碼遊戲","text":"透過連接 API，製作聲音接收器，接收器辨識使用者的發聲，判斷是否符合設定的數字。 純 HTML 畫面 成品畫面 JSgetRandomNum()使用Math.random 創造 0 ~ 1 的數字，在乘上 100 且使用Math.floor讓產生數字 099，最後再加一。利用 console.log 檢查是否產生 0100 的數字 123456const randomNum = getRandomNum();console.log(&quot;number: &quot;,randomNum);function getRandomNum(){ return Math.floor(Math.random()*100) +1;} web Speech APIWeb Speech API 裡面有兩個功能「語音轉文字(Speech Recognition)」跟「文字轉語音(Speech Synthesis )」兩種，本次例子是使用後面「語音轉文字」這個部分。 因為每個瀏覽器支援的部分不同，在導入時要加上webkit字樣以方便我們驅動 API。 12window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 建構一個物件實體。使用 SpeechRecognition()建構式建立物件。 12//create objectlet recognition = new window.SpeechRecognition(); 常用方法： speechrecognition.start():讓 API 開始辨識。 result event 代表辨識使用這說的話，每段話都會存在 results 這個陣列裡面，如果要獲取所辨識的值，可以直接用數字從陣列中取出。 本例透過 result()呼叫getSpeakWord()這個方法; 12recognition.addEventListener('result', getSpeakWord); getSpeakWord()API 辨識使用者的發聲，可先以 console.log 檢查是否成功接收聲音。因為得到的是一串陣列，利用索引值取出聲音資料。 12345function getSpeakWord(e){ // console.log(e) const msg = e.results[0][0].transcript; console.log(msg)} SpeechRecognition 小科普 writeMessage()在 getSpeakWord 函式裡，呼叫寫入呼叫字的函式writeMessage()。 此函式為改變原先在 html 已設定好 id 為 msg 的 html 內容。 123456789function writeMessage(msg){ $('#msg').html( ` &lt;div&gt;You said:&lt;/div&gt; &lt;span class=&quot;box&quot;&gt;${msg}&lt;/span&gt; &lt;div&gt;Go Higher&lt;/div&gt; `);} checkNum()設定判斷條件，首先先設定變數 num，將+msg賦予給 num。這邊 ==+== 是代表將 string 型別的 msg 轉型為 number 型別。 確認是否為數字。 判斷與 randomNum 的大小別，給予提示。 猜對了顯示文字恭喜，結束遊戲。 end event使用 end event，重新呼叫 start() 讓使用者可以根據提示繼續猜下一個數字。.js recognition.addEventListener('end',function(){ recognition.start(); }) click event當猜對數字時，畫面有個 button，設定綁定點擊觸發 reload()事件，讓使用者能再玩一次。 123456//click eventdocument.body.addEventListener('click',function(e){ if(e.target.id == &quot;play-again&quot;){ window.location.reload(); }}) 刷新頁面小科普 tags: javascript","link":"/2021/01/23/JS%E7%B7%B4%E7%BF%92_%E7%B5%82%E6%A5%B5%E5%AF%86%E7%A2%BC%E6%A9%9F/"},{"title":"Javascript_觀念_閉包(Closure)","text":"範圍鏈 Scope Chain 外層取不到內層宣告的變數，但內層可以讀取外層宣告的變數。 例子一: 123456789101112function outer() { b = a * 2; function inner(c) { console.log(&quot;a:&quot;, a, &quot;b:&quot;, b, &quot;c:&quot;, c) } inner(b * 3);}var a = 1;var b = 5;var c = 10;outer(a); 結果： 最裡面的 console.log(a, b, c)在最裡面沒有 abc 的宣告，一層層到外面找，直到找到全域變數有宣告 a/b/c。 但在函式裡 b 被指派由 a 值計算，c 又被指派由 b 計算，在裡面的變數不受外面影響，最後得到的結果是 a:1/ b:2/ c:6。 閉包 Closure再 MDN 上面的解釋是: 閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合。 很好看不懂，換個方式說，當內部函式被回傳時，除自己本身程式碼以外，內部函式內的變數會只會在內部函式，不被外面汙染。也就是一個 函式 回傳另一個 函式。 例子： 123456789101112131415var msg = &quot;global&quot;function outer(msg) { var msg = 'local'; function inner() { return msg } return inner;}var innerFunc = outer();var result = innerFunc()console.log(result); // 結果是：local 雖然是在外面呼叫outer()，都只會回傳inner()裡面的 msg，而不是全域變數的 msg。 計時器（有閉包 v.s 沒閉包） - 沒閉包 12345678for (var i = 1; i &lt;= 5; i++) {setTimeout(function timer() {console.log(i); }, i * 1000)}; i 直到六才迴圈終止，所有這個函式跑出來 666666，六次的六。 有閉包 123456789for (var i = 1; i &lt;= 5; i++) { function cldemo(){ var j = i; setTimeout(function timer() { console.log(i); }}, i * 1000)}; 12利用變數 j 儲存每一次的 i ，這個 i 是有用閉包包起來的，當時間過一秒時 j 是一，過兩秒時 j 是二，console.log 出來就會是 1/2/3/4/5。 tags: javascript,觀念","link":"/2021/04/09/Javascript_%E8%A7%80%E5%BF%B5_Closure(%E9%96%89%E5%8C%85)/"},{"title":"Javascript_觀念_hoisting","text":"什麼是 hoisting提升？提升什麼？提升是一個觀念，可以指==變數提升==或是==函式提升==，電腦就像人類的大腦一樣我們要指派給他做很多事情，每件事情都有自己的儲存空間(記憶體)需先宣告在電腦上才能運行，要是沒有宣告直接取用就是空殼記憶體，啥也沒有，。 只要變數都有在 scope 前被宣告，使用時就不用擔心，出現undfine，referenceError! 先宣告在使用！！！！ 變數提升1234567891011console.log(&quot;1.&quot;, x);var x = 1;function dodo() { console.log(&quot;2.&quot;, x);}console.log(&quot;3.&quot;, x);x = 2;console.log(&quot;4.&quot;, x); 例子１上面有一段程式碼，有四個 console.log，用網頁檢視會出現？ console 因為我們在下面還有宣告變數 x，所以他不會出現not defined，而是會undefined。 console 在函式dodo裡面，我們外面沒有呼叫dodo()所以不會出現。 console，因為我們在 dodo()上面有先宣告 var x =1 ，所以這裡會是 1。 console，我們將２賦予給 x，x 現在是 2 函式提升函式也可以提升，依樣秉持著一原則「先宣告，再使用」 例子一 123456console.log(trytry(11));function trytry(x){ x =10;console.log('try:',x) } console，印出來是 undefined 沒有問題，因為我們 fuc 在他放面才宣告。 console，印出來是 try: 10，再函式裡面就已經找到 x，所以印出來的值是 10 而不是 11。 例子二 1234console.log(trytry(11));function trytry(x){console.log('try:',x) } console，印出來是一樣是 undefined 沒有問題。 console，印出來是 try: 11，再函式裡面就==沒有找到==，在外面找到 11 作為參數傳進來 x，所以印出來的值是 11。 tags: javascript","link":"/2021/04/09/Javascript_%E8%A7%80%E5%BF%B5_hoisting/"},{"title":"Javascript_觀念_事件冒泡&#x2F; 捕獲","text":"事件，是一個媒介，有被觸動(動作)才會有對應的程式碼去執行。 生活的例子：開車。車子原本就在那邊你沒有發動引擎車子是不會動的，還是原封不動的躺在那，那發動引擎就是一個事件，我認為可以把它想成一個動作，做了這個動作才會 xxx。 事件流程網頁元素接收事件的順序。 假設有個 html 網頁內容如下： 1234567891011&lt;body&gt; &lt;div class=&quot;container1&quot;&gt; &lt;ul class=&quot;ul_container&quot;&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 當網頁被瀏覽器載入時，瀏覽器會先分析 html 檔案並把內容解析成很多個網頁元素(DOM)，剛剛提到事件是個動作，就是對這很多個網頁元素所作的動作。 圖片來源- w3c document 這張圖是經典的事件流程圖，主要可以分為三個部分：事件冒泡與事件捕獲，兩個都會執行。 事件捕獲(Capturing)(紅) 由上到下 假設今天我們把圖中的&lt;td&gt;標籤綁定點擊事件，捕獲的事件流程是 document html body table tbody tr 抓到要找的（Target)(藍) 找到 target &lt;td&gt; 事件冒泡(Bubbling)（綠） 由下到上 一樣例子 假設今天我們把圖中的&lt;td&gt;標籤綁定點擊事件，冒泡的事件流程是 tr tbody table body html 回到 document 當我們為id名稱為：tdid的元素綁定點擊事件時，假設&lt;td id = &quot;tdid&quot;&gt;&lt;/td&gt; 12345var tdid = document.getElemenById(&quot;tdid&quot;);tdid.addEventListener(&quot;click&quot;, function () { console.log(&quot;td被點擊了&quot;);}); 瀏覽器會先執行事件捕獲向下找 id 名稱相符的 td 元素，這就是捕獲。在回傳回去 document 就是冒泡，像泡泡一樣向上傳遞給 document。 取消事件傳遞為什麼要取消事件傳遞，因為要是沒有取消的話，我們在編制 html 文件時，常常是一層包一層，我們今天在最裡面增添事件，沒有阻止事件冒泡的話，那外面每一層元素的事件都會被我一起觸發，減少網頁效率。 由上圖我們可以知道事件的流程分為兩條線，事件捕獲或是事件冒泡，這兩條線不論哪條，都可以利用e.stopPropagation進行中斷。 例子 結果只有： 要是我們勾選 Stop propagation，就只會可以得到alert div1，因為我們在 func1 設定了stopPropagation，所以事件不會傳遞到外面的div2，stopPropagation 添加在哪，事件就只會到他那邊而已。 html 部分： 1234567891011&lt;body&gt;&lt;h1&gt;The stopPropagation() Method&lt;/h1&gt;&lt;p&gt;Click DIV 1:&lt;/p&gt;&lt;div onclick=&quot;func2()&quot;&gt;DIV 2 &lt;div onclick=&quot;func1(event)&quot;&gt;DIV 1&lt;/div&gt;&lt;/div&gt;Stop propagation:&lt;input type=&quot;checkbox&quot; id=&quot;check&quot;&gt;&lt;/body&gt; JS 部分： 12345678910111213&lt;script&gt;function func1(event) { alert(&quot;DIV 1&quot;); if (document.getElementById(&quot;check&quot;).checked) { event.stopPropagation(); }}function func2() { alert(&quot;DIV 2&quot;);}&lt;/script&gt; 取消預設的行為e.stopPropagation 和 e.preventDefault常常被拿來做比較。 再次確認定義：e.stopPropagation：取消事件的傳遞。e.preventDefault：取消預設的行為。 例子:取消超連結的連結 1&lt;a id=&quot;a-link&quot; href=&quot;https://google.com&quot;&gt;google&lt;/a&gt; 通常點擊google就會連結的 google 的首頁，a 標籤預設有連結網頁的功能，我們現在要把他取消。 123document.getElementById(&quot;a-link&quot;).addEventListener(&quot;click&quot;, function(event){ event.preventDefault()}); 增加了只要點擊id：a-link的物件，就會把預設的行為(超連結)停止，這樣怎麼點也點不到 google 首頁。 tags: javascript","link":"/2021/04/09/Javascript_%E8%A7%80%E5%BF%B5_%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1_%20%E6%8D%95%E7%8D%B2/"},{"title":"Javascript_觀念_函式及作用域","text":"函式是一個指令或多個指令一起被包在括號裡面，可以重複被調用的==物件==。 定義方式函式宣告 表示式：JS 可以指派 function 給一個變數（其他語言無法） 例子一 1234567var x = function(){return &quot;123&quot;}//x() 可直接執行 結果-&gt;123 直接式：直接定義函式 例子二 1234567891011function add(a, b){return a+b}add(2,3) //結果5minus = function(x,y){return x-y}minus(100,10) 函式運算以剛剛例子二範例，我們函式 add，會回傳參數 a 與參數 b 的相加結果，這個就是內的運算 函式可以做的事函式是一個物件，物件可以做的事，函式都可以做。 可以當作參數被傳入 1234567//原本的funcAfunction funcA(){xxxx}var newA = function oddA(funcA){console.log(&quot;函式可以當作參數&quot;)} 可以有自己的屬性 1234567//原本的funcAfunction funcB(){xxxx}funcB.name = &quot;bb&quot;console.log(funcB.name); //結果是 bb} 可以被呼叫 1234567//原本的funcCfunction funcc(){console.log(&quot;我是 funcC&quot;)}funcC()//結果是 我是 funcC} 可以沒有名字 123456let ans = function (a,b){return a+b}consolo.log(ans) //結果是 a+b 作用域 Scope函式內所定義的變數只屬於==函式內==使用。 12345678var x = 100;function hi(x){var x =10;console.log(&quot;x現在是：&quot;, x);}hi(); //得到的結果是 x現在是：10;console.log(x) 得到的結果是 100; 同樣的變數在全域裡 x 是 100，但是在函式 hi 裡，x 有被指派新的值，但這也僅限在函式內部使用，在外面 x 還是全域變數 100。 tags: javascript,觀念","link":"/2021/04/09/Javascript_%E8%A7%80%E5%BF%B5_%E5%87%BD%E5%BC%8F%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"command_line","slug":"command-line","link":"/tags/command-line/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"JS_練習","slug":"JS-練習","link":"/tags/JS-%E7%B7%B4%E7%BF%92/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"PesodoCode","slug":"PesodoCode","link":"/tags/PesodoCode/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"JS觀念","slug":"JS觀念","link":"/tags/JS%E8%A7%80%E5%BF%B5/"}],"categories":[]}