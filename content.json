{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"css_練習_偽類及偽元素","text":"偽類(pseudo-cleass) 互動式的類別 以 :: 為開頭，但也可以以 : 為開頭 不存在在 document tree :hover 當滑鼠游標滑過物件時產生反應 :active 在使用者按下滑鼠按鈕並放開它之間的時間會產生反應 :focus 當元素有焦點時會對此偽類產生反應，例如：按鍵盤的 Tab 鍵所選到的元素 :nth-child() 選取第 n 個子物件，n 就是我們給予的條件，會寫至（）裡。 例子：要是我們有一串 li 標籤，然後我們想要選取奇數欄的 li，便輸入ul :nth-child(odd) 記得 ul 後面有空格 例子：要是我們一串 li 標籤，然後我們想每三個元素就把該 li 值變成紅色，便輸入ul :nth-child(3n) 括號裡是可以帶入公式的。 Demo 傳送門 偽元素(pseudo-element) 不存在在 document tree 一定要有 ==content:’可有可無內容’== 因為偽元素的初始值是 normal 計算值是 null，要是沒有 content 的話，他們就會被認定不是偽元素了 ::before/ :: after 在原始元素的內容之前/後建立的子偽元素 display 都是 inline，會產生 inline box 可以跟其他元素共享一行 瀏覽器的結果會是 Demo 編筐三角形 tags: css","link":"/2020/12/01/CSS%20%E9%81%B8%E5%8F%96%E5%99%A8/"},{"title":"Command Line 常用筆記","text":"這裡要介紹常用的 command line 指令，讓自己更熟悉使用 commandline 跟電腦溝通。 command line 基本指令介紹 要是不知道這指令什麼意思 -&gt; 好幫手「tldr」 基本指令介紹ls ls = list 列出所有檔案和路徑 寫法變化 列出隱藏的目錄：ls -a 列出詳細資料：ls -l 包上述兩個：ls -la 列出 .js 的檔案：ls *.js cd cd = change directory 切換目錄 寫法： cd '要去的目的地' 狀況：假如我想要從我們 User/apple，前往桌面上一個叫做 Chris_Coding 的資料夾，便在 iterm 輸入 1cd Desktop/Chris_Coding 原本長這樣後來就會在 Chris_Coding 的資料夾裡了 寫法變化 cd . 一個點：代表所在目錄 cd .. 兩個點：代表回去上一層目錄 ==小訣竅==：輸入 cd 空格後再按住 tab 鍵會有像打出 ls 的功能，可以選擇要去資料夾 pwd 顯示目前所在位置 cat功能有三 顯示文件所有内容 cat filename 創建一个新文件cat &gt; filename(只能創建新文件不能編輯已有文件)打完文件內容記得要按ctrl +d結束。 把文件合併成一個文件cat file1 file2 &gt; filexxx touch 碰一下檔案 寫法：touch 檔名情況一：假設檔案不存在，就會建立一個新的檔案。情況二：假設檔案存在，更改檔案些改時間。 mkdir mkdir = make directory 新增資料夾 寫法：mkdir xxx 可以先用cd xx 到你想要去的資料夾創造你想要的資料夾，就可以用mkdir xxx創造你需要的資料夾 rm rm = remove 刪除檔案 寫法: rm xxx.html 刪除某 html 檔 rmdir 刪除空資料夾，若資料夾內有檔案就無法刪除。 rm -rf 刪除整個檔案或整個資料夾 ＃謹慎使用，刪掉就真掰掰了。＊rm 檔案 就真的是刪掉檔案，使用時請小心！ mv mv = move file 用來為文件或目錄改名、或將文件或目錄移到其它位置 原本長這樣 後來變那樣 mv fileA fileB 會將 a 文件改成 b 文件 mv fileA abc(目錄) 會將 a 文件移到 abc 資料夾 mv def(目錄) abc(目錄) 要是 abc 目錄存在，會將 def 目錄移到 abc 目錄/ 要是 abc 目錄不存在，會將 def 目錄改為 abc 目錄 mv def(目錄) fileA 失敗！ sudo 取得權限 clear 清空畫面 cp cp = copy 複製檔案 寫法：cp “要複製的檔案” 123cp aaa.html bbb.html # 把檔案 aaa.html 複製一份成 bbb.htmlcp -r xx(資料夾) yy(資料夾) # 把 xx 資料夾 複製 進去 yy資料夾中 tldr當使用終端機時，我們常常會忘記如何寫命令或是不知道怎麼下筆，這時好幫手 「tldr」出現了。 tldr 是什麼？ 一個 command line 的開源工具 tldr = too long ; didn’t read （太長不想讀） 使用情況： 知道指令，但忘記怎麼用 遇到沒看過的指令，不知道如何用 安裝 tldr 打開 iterm 輸入 12brew tap tldr-pages/tldrbrew install tldr 小實驗 狀況假如我忘記 mkdir 是什麼意思？我們可以再 iterm 輸入 tldr mkdir它便會告訴我們 mkdir 的用法","link":"/2020/11/05/Command%20Line%E5%B8%B8%E7%94%A8%E7%AD%86%E8%A8%98/"},{"title":"HTML CSS Javascript 網頁三兄弟","text":"圖片來源 HTML=== HyperText Markup Language 的縮寫 中文：超文本標記語言 標記式語言是什麼？-&gt; 由很多個&lt;標籤&gt;所組成，用大小於&lt; &gt;包住你想要的 HTML 元素，結尾再用大小於包住斜線/+元素1&lt;xxx&gt;&lt;/xxx&gt; 1 構成網頁的組織架構並呈現網頁的內容（就像最上面的圖的骨頭一樣） 網頁內容包括文字、圖片、段落、表格、清單…很多標籤可以使用 範例寫法： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;first&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;fiest&lt;/h1&gt; &lt;p&gt;this is my first html&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 瀏覽器呈現結果： 寫法 一定要有&lt;!DOCTYPE html&gt;這行，因為這是告訴瀏覽器這是一個 html 檔 &lt;html&gt;&lt;/html&gt;裡面包覆著&lt;head&gt;跟&lt;body&gt;這個標籤用來包覆整個 html 的程式碼 在 與 標籤裡面的內容詳述，請詳 HTML tag 標籤介紹 CSS Cascading Style Sheets 的縮寫 中文：層疊樣式表 決定網頁的外觀長的怎樣。可以決定文字表格顏色、字體、編筐設定排版…等(就像最上面的圖他代表人的皮膚及外在的裝飾衣物) ==不可單獨使用==需搭配 html 一同使用 可以寫在 html 裡，也可以以 link 做連結，連到檔案外以.css 做結尾的檔案 內容：CSS 由多組「規則」組成。每個規則由「選擇器」（selector）、 「屬性」（property）和「值」（value）組成： 選擇器（Selector）：多個選擇器可以半形逗號（,）隔開。 屬性（property）：CSS1、CSS2、CSS3 規定了許多的屬性，目的在控制選擇器的樣式。 值（value）：指屬性接受的設定值，多個關鍵字時大都以空格隔開。 屬性和值之間用半形冒號 : 隔開，屬性和值合稱為「特性」。多個特性間用 ; 隔開，最后用 { } 括起來。 Javascipt 簡稱 JS，跟 Java 是不同的語言不要搞混 是一種腳本語言，協助我們建立動態網頁，使我們能動態的更新內容、控制多媒體、動畫……等等等。 可以寫在 html 裡，也可以另外用一個 css 以 link 做連結 tags: html、css、javascript","link":"/2020/11/07/HTML%20CSS%20Javascript%E7%B6%B2%E9%A0%81%E4%B8%89%E5%85%84%E5%BC%9F/"},{"title":"JS_觀念_Promise","text":"Promise是 ES_6 的語法，針對 JS 做非同步的處理。非同步就是不用等上一部執行完成，才做下一步，每個步驟是可以同步執行的。一個 Promise 會帶有兩個參數，成功與失敗。 語法 1234567891011const creatPromise = new Promise((resolve, reject)=&gt;{ /**成功時回傳的**/ resolve(status) /**失敗時回傳的**/ reject(status)}).then((data)=&gt;{ /**用 then 接續成功時的處理**/}).catch((error)=&gt;{ /**用 catch 接續失敗時的處理**/ JS_fetchferch 是一個全域 windows 物件，主要是搭配 Promise 來執行請求網站和請求後獲取 Response 的處理方式。當送出 request 出去要訪問的 url，若成功則會回傳 response(裡面帶有我們想要的物件) 語法 123456fetch(url(要訪問的網頁）,{method: '方法'}(參數).then(function(response){//成功的結果}).catch(function(response){//失敗的結果}) jQuery AJAX12345678910111213141516171819202122232425262728293031323334353637383940// 使用 $.ajax() 方法$.ajax({ // 要送要求的網址(URL) url: './sample.json', // 要送出的資料 (會被自動轉成查詢字串) data: { id: 'a001' }, // 要使用的要求method(方法)，POST 或 GET type: 'GET', // 資料的類型 dataType : 'json', // 成功時要做什麼 success: function(){...}, // 失敗時要做什麼 error: function(){...},}) // 要求成功時後，要執行的程式碼 // 回應會被傳遞到回調函式的參數 .done(function( json ) { $( '&lt;h1&gt;' ).text( json.title ).appendTo( 'body' ); }) // 要求失敗時後，要執行的程式碼 // 狀態碼會被傳遞到回調函式的參數 .fail(function( xhr, status, errorThrown ) { console.log( '出現錯誤，無法完成!' ) console.log( 'Error: ' + errorThrown ) console.log( 'Status: ' + status ) console.dir( xhr ) }) // 不論成功或失敗都會執行的回調函式 .always(function( xhr, status ) { console.log( '要求已完成!' ) }) tags: javascript","link":"/2021/03/25/JS_Promise/"},{"title":"JS_練習_2022新年倒數計時器","text":"製作一個距離 2022 年一月一日的倒數計時器。 成品畫面 功能 觸碰標題會有藍光 打字動畫無限循環 時間倒數畫面呈現 CSSbody::after在跟元素body後面利用after建立一層黑模，使畫面更有質感。 123456789body::after{ content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0, .3);} body *利用z-index使 body 內部所有東西都放到最上層。 123body * { z-index: 1;} text-shadow利用屬性text-shadow 在 h1 被碰到的時候，會產生文字背影。 12345678910h1:hover{ text-shadow: 0 0 10px #3498DB, 0 0 20px #3498DB, 0 0 30px #3498DB, 0 0 40px #2980B9, 0 0 70px #2980B9, 0 0 80px #2980B9, 0 0 100px #2980B9, 0 0 150px #2980B9;} 打字動畫讓文字一個一個被打出來，可以利用 css 的step()還有overflow屬性。 step()讓元素在畫面不連續，他會依照設定的影格格數切割動畫，不補入過度動畫。 語法step(格數, position(start/ end(可省略))) number 代表我們把動畫切了幾段 position 代表動畫是從時間 開頭連續 還是結尾連續，支持start或是 end這兩個屬性值。 圖片來源: https://www.w3.org/TR/css-easing-1/#step-timing-functions - start: 表示時間開始時，已經執行了一段了 - end: 默認值。表示時間開始，才會開始執行 overflow定義元素超過某個範圍的時候該如何呈現。常見屬性: visible: 內容不會被修改，當超出元素的範圍時內容會呈現在元素框之外。 hidden: 內容會被修改，但不會顯示捲軸，當超出元素的範圍時會隱藏內容。 scroll: 內容會被修改，超出範圍自動變成捲軸方式呈現。 auto: 自動選擇由瀏覽器決定如何顯示(預設值)，當超出範圍時自動以捲軸方式呈現。 overflow-x: 可設定「水平」方向，當超出範圍時自動變成捲軸呈現方式。(需要內有寬度大於元素框的物件) overflow-y: 可設定「垂直」方向，當超出範圍時自動變成捲軸呈現方式。 overflow 小科普 white-wrap主要特性是決定如何處理元素內的空白字元，要是打字動畫打的內容長度過長，文字會被拆行。利用white-wrap 讓畫面只呈現一行。 white-wrap 小科普 JSremainTime() 先設定目前的時間變數，設定時間變數的方式是new Date() 取得剩餘的時間。將 2022 年一月一日與目前時間相減，得到剩餘時間(單位：毫秒)。 設定變數day、hour、min、sec，並用取餘數的方式，得到截至今日結束前的剩餘時間。 將剩餘時間放入 html 設定好的元素。 1234567891011121314151617181920212223//創造變數，得知現在是幾年const currentYear = new Date().getFullYear();// console.log(currentYear);//const countDownTime = new Date(`January 01 ${currentYear + 1} 00:00:00`);// console.log(countDownTime)function remainTime(){ const timeNow = new Date(); // console.log(timeNow) const remain = countDownTime - timeNow;//得到的是毫秒 // console.log(remain) //定義remain的剩下幾天幾時幾分幾秒 const sec = Math.floor(remain/1000)%60; const min = Math.floor(remain/1000/60)%60; const hour = Math.floor(remain/1000/60/60)%24; const day = Math.floor(remain/1000/60/60/24); $('#days').text(timeExpress(day)); $('#hours').text(timeExpress(hour)); $('#minutes').text(timeExpress(min)); $('#seconds').text(timeExpress(sec));} timeinterval 設定計時器，透過設定setInterval來==重複== 執行函式，設定延遲時間，在每間隔多久後再執行程式碼，最後並回傳一個 timerID。 設定條件，要是剩餘時間已經 &lt; 0，則呼叫clearInterval()以結束循環。 123456789const timeinterval = setInterval(function(){ var t = countDownTime - (new Date()); // console.log(t) if(t&lt;0){ clearInterval(timeinterval); }else{ remainTime() }},1000); tags: javascript","link":"/2021/01/28/JS%E7%B7%B4%E7%BF%92_2022%E6%96%B0%E5%B9%B4%E5%80%92%E6%95%B8%E8%A8%88%E6%99%82%E5%99%A8/"},{"title":"JS_練習_Youtube 搜尋器","text":"製作一個 youtube 搜尋頁面，讓使用者可以輸入關鍵字，依照關鍵字搜尋符合關鍵字的內容影片並有上/下頁功能的選擇。 成品畫面 功能 輸入內容 使用者輸入的內容，搜尋影片 有上一頁/ 下一頁按鈕，頁面跳轉 JS申請 API key前往一個 Google cloudclub Platform 建立專案輸入專案名稱進來專案內容後，點選建立憑證，API 金鑰點選旁邊的資訊主頁，點選啟用 API 和服務，搜尋我們這次要使用的 API Youtube Data API v3 使用$(document).ready() 確定 DOM 的完全載入 設定 key 的變數 加入 form 的 submit事件 設定防呆機制 呼叫videoSearch() videoSearch() 參數：key/ search/ maxResult 先將要展示搜尋結果那個 html 內容清除 使用 jQuery get方法，設定傳入的 url 像這邊是我們是使用 youtube 的 search API，在官方的說明文件中先貼上 search API 文件中的 urlhttps://www.googleapis.com/youtube/v3，再做其他參數欄位設定。 console.log 出來 JSON 結果的資料觀察我們需要的資料 data 裡面的 items 將每個data.items透過forEach方式取得每一筆 item 的資料，並呼叫getOutput方法創造 html 內容，將內容貼在 $('#videos')後。 創造一個 button 點擊時，會觸發getButton() getButton()判斷 token 是否為prevPageToken，並設定 button 的 html 內容屬性，及點擊會促發nextPage()與prevPage()函式。 倘若是 -&gt;會有兩個 button，Previous/ Next button。 倘若不是 -&gt; 只會有 Next button。 123456789101112function getButton(prevPageToken, nextPageToken){ let q; if(!prevPageToken){ var btnOutput = '&lt;div class=&quot;button-container&quot;&gt;' + '&lt;button id=&quot;next-button&quot; class=&quot;paging-button&quot; data-token=&quot;' +nextPageToken+'&quot; data-query=&quot;'+q+'&quot;+ onclick=&quot;nextPage();&quot;&gt;Next Page&lt;/button&gt;&lt;/div&gt;'; }else{ var btnOutput = '&lt;div class=&quot;button-container&quot;&gt;' + '&lt;button id=&quot;prev-button&quot; class=&quot;paging-button&quot; data-token=&quot;' +prevPageToken+'&quot; data-query=&quot;'+q+'&quot;+ onclick=&quot;prevPage();&quot;&gt;Previous Page&lt;/button&gt;'+ '&lt;button id=&quot;next-button&quot; class=&quot;paging-button&quot; data-token=&quot;' +nextPageToken+'&quot; data-query=&quot;'+q+'&quot;+ onclick=&quot;nextPage();&quot;&gt;Next Page&lt;/button&gt; &lt;/div&gt;'; } return btnOutput;} getOutput(item)設定一些從 JSON 檔觀察出的變數，建立成 output 字串(有標題、圖片及文字的 html 內容)，return output 內容至呼叫函式的地方。 123456789101112131415161718192021222324252627282930313233343536function getOutput(item){ var videoId = item.id.videoId; var title = item.snippet.title; var description = item.snippet.description; var thumb = item.snippet.thumbnails.high.url; var channelTitle = item.snippet.channelTitle; var videoDate = item.snippet.publishedAt; // Build Output String var output = &quot;&lt;li&gt;&quot; + '&lt;div class=&quot;list-left&quot;&gt;' + '&lt;img src=&quot;' + thumb + '&quot;&gt;' + &quot;&lt;/div&gt;&quot; + '&lt;div class=&quot;list-right&quot;&gt;' + '&lt;h3&gt;&lt;a class=&quot;fancybox fancybox.iframe&quot; href=&quot;http://www.youtube.com/embed/' + videoId + '&quot;&gt;' + title + &quot;&lt;/a&gt;&lt;/h3&gt;&quot; + '&lt;small&gt;By &lt;span class=&quot;cTitle&quot;&gt;' + channelTitle + &quot;&lt;/span&gt; on &quot; + videoDate + &quot;&lt;/small&gt;&quot; + &quot;&lt;p&gt;&quot; + description + &quot;&lt;/p&gt;&quot; + &quot;&lt;/div&gt;&quot; + &quot;&lt;/li&gt;&quot; + '&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;' + &quot;&quot;; return output;} ==＊== return 很重要，要是沒有 return 東西只是被創造出來，不會丟回去 html 裡。 nextPage() / prevPage()使用搜尋功能搜出影片後，在頁面會出現一個next page的 button，點擊促發 nextPage()函式，這裡函式跟videoSearch()很像，主要差別在，由上面我們先跑出來的 data，觀察出要帶入下一頁或上一頁的資訊必須要有一個 token，才可以帶入，這裡先定義 token 及 q 的變數，再帶入$.get中，之後跑出來的 data，一樣創造 html 內容 1234567891011121314151617181920212223242526272829303132333435//nextpage buttonfunction nextPage(){ let token = $('#next-button').data('token'); console.log(token) let q = $('#next-button').data('query'); $('#videos').html(''); $('#button').html(''); q = $(&quot;#search&quot;).val(); $.get(&quot;https://www.googleapis.com/youtube/v3/search&quot;,{ key: 'AIzaSyCSwkueGwGH8xdWDDgcMMAdXDRxKg0uEiE', type: 'video', part: 'snippet, id', pageToken: token, q: q, }, function(data){ let prevPageToken = data.prevPageToken; let nextPageToken = data.nextPageToken; console.log(data); data.items.forEach(item =&gt; { video = getOutput(item); $(&quot;#videos&quot;).append(video); }); //show button let buttons =getButton(prevPageToken, nextPageToken); $('#button').append(buttons); })} fancyboxFancyBox 是一套 jQuery 的套件，可以可以套用在圖片及影片上呈現放大燈箱的效果。 fancyBox CDN 官方 document ==注意==再 index.html 中，最後要有啟用的動作，不然會沒有效果。 1234567891011&lt;script&gt; $('[data-fancybox]').fancybox({ youtube : { controls : 0, showinfo : 0 }, vimeo : { color : 'f00' } });&lt;/script&gt; tags: javascript","link":"/2021/02/21/JS%E7%B7%B4%E7%BF%92_Youtube%E6%90%9C%E5%B0%8B%E5%99%A8/"},{"title":"JS_練習_匯率轉換器","text":"手切匯率轉換器模板，帶入匯率 API，使輸入金額即呈現轉換後的金額。 成品畫面 功能 可以選擇想要的幣別帶入當下匯率 互換幣別，轉換結果 HTML 利用 select 與 option 標籤做出下拉選單的樣式。並在每個選項有加入代表匯率幣值的值 value。 CSS 利用變數的形式，讓元素在取用顏色上面更方便 1234:root { --primary-color: #5fbaa7;}/* background: var(--primary-color); 需要使用時填入*/ 利用設定 RWD 的變化，讓畫面可以隨著螢幕的伸縮而跟著轉換。 12345@media (max-width: 600px) { .currency input { width: 200px; }} JS1. 事件利用 change/ click 事件讓使用者可以透過 輸入金額按下enter就可以得到已乘上匯率後的金額 按下 swap 執行幣別轉換，並更新金額 2. 套入 API觀察 API發現我們要的匯率資料在rates在 javascript 是利用 fetch()方法套入 API，輸入你要做的事。fetch 筆記這裡我們要執行兩件事： 將 rate 的值更改。 因為點擊 swap 而修改 因為輸入金額的修正而更改 input 的 amount 值修正。帶入更新後的 rate 與 amount-one 相乘 1234567891011121314151617function calculate() { const currency_one = $('#currency-one').val(); const currency_two = $('#currency-two').val(); fetch(`https://api.exchangerate-api.com/v4/latest/${currency_one}`) // .then(function(res) { //回傳 參數的json值 return res.json(); }) .then(function(data) { const rate = data.rates[currency_two]; $('#rate').text(`1 ${currency_one} = ${rate} ${currency_two}`); $('#amount-two').val(($('#amount-one').val() * rate).toFixed(4)); });} 3. val()在 javascript 裡要取得 value，我們會透過 物件/元素.value來取值和賦予值。 1234567// get valuevar value1 = document.getElementById('currency-one').value;var value2 = document.getElementById('currency-two').value;// assign new valuedocument.getElementById('currency-one').value = &quot;new value 123&quot;;document.getElementById('currency-two').value = &quot;new value 456&quot; 但在 jQuery 裡要透過 .val() 獲取值且利用 **val(填入要改變值)**，將值改變。 1234567// get valuevar value1 = $(&quot;.currency-one&quot;).val();var value2 = $(&quot;.currency-two&quot;).val();// assign new value$(&quot;.currency-one&quot;).val(&quot;new value 123&quot;);$(&quot;.currency-two&quot;).val(&quot;new value 456&quot;); 本次例子 我們利用 val()取值，將匯率 1 的值 賦予給 temp 將匯率 1 的值 改為匯率 2 的值。在 jQuery 裡是利用val()裡賦值 再將原來temp變數中儲存的匯率 1 的值賦予給匯率 2 最後在呼叫函式進行重新計算 1234567$('#swap').click(function(){ var temp = $('#currency-one').val(); $('#currency-one').val($('#currency-two').val()); $('#currency-two').val(temp); var currency_one = $('#currency-one').val(); var curreㄟncy_two = $('#currency-two').val(); calculate(); tags: javascript jQuery","link":"/2021/01/14/JS%E7%B7%B4%E7%BF%92_%E5%8C%AF%E7%8E%87%E8%BD%89%E6%8F%9B%E5%99%A8/"},{"title":"JS_練習_天氣API","text":"透過抓取中央氣象局的公開 API 資料，抓取台灣各縣市的當下天氣情況及未來一週天氣預報，透過下拉式選單選取不同縣市，以取得不同的天氣圖片所表示不同的天氣狀況。 成品畫面 先導入 jQuery 以及 bootstarap，透過先設定好縣市的天氣內容，以利編輯 CSS 的部分。 功能 下拉式選單選取不同縣市 顯示選取城市的當下天氣資料 顯示選取城市未來一週天氣資料及溫度 JavaScript$.ajax({})申請ＡＰＩ 到中央氣象局網站加入會員 點選取得授權碼 前往中央氣象局開放資料平臺之資料擷取 API將剛剛得到的 url 貼到想要查詢的頁面產生==URL== 利用$.ajax()輸入剛剛得到的 url 抓取中央氣象局 JSON 的資料，成功時會觸發todayWeather、selectCity與weekWeather這幾個函式。 觀察 JSON 檔，確認所需要的資料是在檔案的什麼位置，並用console.log印出來檢視內容。 在開發者工具試著打印data.location[cityNum].weatherElement，確認我們可以得到一個有 15 個氣象資訊的陣列變數。之後要取用資料時，便得確認該資料的位置帶入相關索引值。 1234567891011121314$.ajax({ url:'https://opendata.cwb.gov.tw/api/v1/rest/datastore/F-D0047-091?Authorization=CWB-373C6328-6BF2-41B3-BB3B-147802B82875&amp;format=JSON&amp;locationName=&amp;elementName=&amp;sort=time', method: &quot;GET&quot;, datatype:&quot;json&quot;, success: function(res){ data = res.records.locations[0]; // console.log(data); city = data.location; // console.log(city); todayWeather(data, cityNum); selectCity(city); weekWeather(data, cityNum); }}) todayWeather() 先把原先在 index.html 中設定的假的 html 內容先設定為空。 創造一個取得現在時間的函數，並把最後的 GMT 時區用split（）方式移除。 在$.ajax()那已確認所需資料於 JSON 檔的位置，這裡便可以直接指定變數。 將設定好的變數再度放回 index.html 中。 1234567891011121314151617181920function todayWeather(data, cityNum){ // console.log(123) $('#weatherNow').html(''); chooseCity = data.location[cityNum].locationName // console.log(chooseCity); todayDate = new Date().toString().split(&quot;GMT&quot;)[0]; let weather = data.location[cityNum].weatherElement; weatherDescription = weather[6].time[0].elementValue[0].value; let weatherTemp = data.location[cityNum].weatherElement[1].time[0].elementValue[0].value; let weatherImg = changeImg(weatherDescription); $('.weather_now').html(` &lt;h1&gt;${chooseCity}&lt;/h1&gt; &lt;h2&gt;${todayDate}&lt;/h2&gt; ${weatherImg} &lt;div class=&quot;now-description&quot;&gt;${weatherDescription}&lt;/div&gt; &lt;p&gt;溫度: ${weatherTemp} °C&lt;/p&gt; `)} selectCity()data參數是我們一開始在$.ajax()所觀察出來在 JSON 檔中的資料，再利用加上 localName 屬性，取得台灣縣市名稱。利用迴圈放入select選單中，使選單出現台灣各縣市。 1234567891011function selectCity(data){ const $ = document.querySelector.bind(document); let select = $('select'); for(let i =0;i&lt; data.length;i++){ city = data[i].locationName; let value =i; select.innerHTML += ` &lt;option value=&quot;${value}&quot;&gt;${city}&lt;/option&gt;; } // console.log(city);} changeImg()假設各式天氣狀況，當內容文字符合之時，便會秀出天氣圖片。 123456789function changeImg(weatherDescription){ if(weatherDescription === '多雲時晴' || weatherDescription === '晴時多雲' ){ return '&lt;img src=&quot;./img/sun.png&quot; alt=&quot;sun-cloudy&quot;&gt;' }else if(weatherDescription === '多雲' || weatherDescription === '陰時多雲' || weatherDescription === '多雲時陰'){ return '&lt;img src=&quot;./img/cloudy.png&quot; alt=&quot;cloudy&quot;&gt;' }else{ return '&lt;img src=&quot;./img/drop.png&quot; alt=&quot;rainy&quot;&gt;' }} 天氣圖片資料來源 weekWeather() 先將原先的 html 先清除。 將創造出的 div 給定day屬性方便做 CSS 方面的修改。 設定各項氣象資料變數。 設定時間函數取得當前時間，星期幾及時間。 將設定好的變數再度放回 index.html 中 使用append()方法將資料參數放入&lt;div id='week'&gt;&lt;/div&gt;元素後面。 1234567891011121314151617181920212223function weekWeather(data, cityNum){ $('#week').html(''); let oneWeek =['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']; let weekDay =[] for (i = 1; i &lt; 7; i++) { let timeIndex = 2 * i; let day = $('&lt;div&gt;&lt;/div&gt;').attr('class', `day`); nextWeekNum = new Date().getDay()+1; let weather = data.location[cityNum].weatherElement; weatherDescription = weather[6].time[timeIndex].elementValue[0].value; let weatherTemp = data.location[cityNum].weatherElement[1].time[timeIndex].elementValue[0].value; let weatherImg = changeImg(weatherDescription); day.html(` &lt;h3&gt;${oneWeek[i]}&lt;/h3&gt; ${weatherImg} &lt;div class=&quot;week-description&quot;&gt;${weatherDescription}&lt;/div&gt; &lt;p&gt;溫度: ${weatherTemp} °C&lt;/p&gt; `); $('#week').append(day); } change 事件將下拉式選單select綁定change事件，當選單內容改變時便會觸發·todayWeather與weekWeather函式 123456$('#select').change(function() { // console.log(123) cityNum = $('#select :selected').val(); todayWeather(data, cityNum); weekWeather(data, cityNum);}); tags: javascript","link":"/2021/02/15/JS%E7%B7%B4%E7%BF%92_%E5%A4%A9%E6%B0%A3API/"},{"title":"JS_練習_打字小遊戲","text":"製作一個打字遊戲，透過設定困難度，測試使用者在一定的時間內的打字速度及正確性。 成品畫面 成品網址 純 html 畫面 HTML 使用form、selector做出選取困難程度的表單 下方使用input標籤，讓使用者得以輸入文字測試結果 CSS雖然 html 只有用空的容器表示，但還是在 css 先設定屬性，待在 JS 呼叫時可以直接顯示。 background-color設定inherit繼承父元素的 background-color。 disflex先設定：none，等 JS 在增改屬性為flex。 z-index設定為一，讓他顯示在最上面。 1234567891011121314.end-game-container{ background-color: inherit; display: none; align-items: center; justify-content: center; flex-direction: column; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;} JS 隨機產生單字 打完單字，比較是否輸入正確 輸入正確跳下一個單字 輸入正確清除打字欄準備輸入下一個字 RandomWord() 目的：隨機產生單字 way Ｉ先定義數字陣列，設定函式 return word[]索引值。利用 Math.random 產生 0~1 的數字，再利用 Math.floor 進行 rounddown，產生整數索引值。 123456789101112131415161718192021222324252627const words= [ 'sigh', 'tense', 'airplane', 'ball', 'pies', 'juice', 'warlike', 'bad', 'north', 'dependent', 'steer', 'silver', 'hoghfalutin', 'superficial', 'quince', 'eight', 'feeble', 'admit', 'drag', 'loving'];function getRandomWord(){ return words[Math.floor(Math.random()* words.length)]} wayII使用 ajax，利用 API 得到隨機產生的單字，並放入&lt;h1&gt; 隨機產生單字 API 12345678$.ajax({ method: &quot;get&quot;, url: 'https://random-word-api.herokuapp.com/word?number=1', dataType: &quot;json&quot;, success: function (data) { $('h1').text(data); }}); input event當使用者在input輸入值，觸發事件。條件一：確認輸入值是否等於 randomWord()產生的單字條件二：當條件一成立： 執行更新分數 清除 input 欄位的值 1234567891011121314151617181920//input event listener$('#text').on('input',function(e){ const insertText = $(e.target).val(); // console.log(insertText) let randomWord = $('h1').text(); if(insertText == randomWord ){ // console.log(&quot;yes!&quot;) RandomWord(); //update the score updateScore() function updateScore(){ score++; $('#score').text(score); } //每打完一個字，clear input $(e.target).val(''); }}) focus()選取$('#text')，當畫面 reload 時，滑鼠游標自動帶到 input 裡。 12$('#text').focus(); updateTime()使設定的變數time遞減，並將值寫入$('#time')裡。要是時間到 0，執行 clearInterval() setInterval() 延遲了某段時間 (單位為毫秒)後，才執行「一次」指定的程式碼，並且會回傳一個獨立的 timer ID。 會在間隔固定的時間不斷重複，直到呼叫clearInterval()。 setInterval 小科普 setTimeout() 是固定延遲了某段時間之後，才去執行對應的程式碼，然後 ==不斷循環==。 當然也會回傳一個獨立的 timer ID。 只會執行一次就結束。 setTimeout 小科普 clearInterval() 可以取消由 setInterval() 設定的 timeout。 clearInterval 小科普 123456789function updateTime(){ time--; $('#time').text(time + 's'); if(time === 0){ clearInterval(timeInterval); gameOver(); }} gameOver()當遊戲結束，將原先 html 設置的&lt;div id=&quot;end-game-contianer&quot;&gt;寫上遊戲結束的內容，並將其容器的 css 屬性改為display:flex location.reload():是一個放讓瀏覽器重新整理的方法。 location.reload()小科普 1234567function gameOver(){ $('#end-game-container').html(` &lt;h1&gt;Time ran out&lt;/h1&gt; &lt;p&gt;Your final score is ${score}&lt;/p&gt; &lt;button onclick= &quot;location.reload()&quot;&gt;Reload&lt;/button&gt; `).css('display','flex');} setting difficulty 設定遊戲的困難度是由存放在 localstorage 的困難度還是是直接設定medium。 當畫面 reload 時，困難度不會改變，會按照之前所選的困難度。 123456//設定困難度是由設定在localstorage的困難度還是'medium'// let difficulty = 'medium';let difficulty = localStorage.getItem('difficulty') !==null? localStorage.getItem('difficulty') : 'medium';//set difficulty select value$('#difficulty').val(localStorage.getItem('difficulty') !==null? localStorage.getItem('difficulty') : 'medium'); tags: javascript","link":"/2021/01/22/JS%E7%B7%B4%E7%BF%92_%E6%89%93%E5%AD%97%E5%B0%8F%E9%81%8A%E6%88%B2/"},{"title":"JS_練習_無限轉軸頁面","text":"製作一個無限捲軸的搜尋頁面，並依照關鍵字搜尋假文 成品頁面 功能 按照搜尋關鍵字搜尋符合之假文 HTML先利用 html 寫上假設的項目列表，以利方便設定 css 的樣式。 最上面用一容器包覆&lt;input&gt;製作可搜尋的欄位， 中間則是容器，包覆搜尋的項目。 最下面為 loading point。 CSS 單位 px：像素，無法像公分或是公尺具體化一像素寬多少/高多少，像素的寬跟高是依顯示器的解析度做判斷。 em：相對單位。繼承父層元素的寬高設定，要是沒有父層元素就是瀏覽器的根元素預設設定（瀏覽器預設字體大小為 16px)。 vh/vw：相對單位。根據可視視窗寬高決定百分比伸縮的單位。語法上省略%這個符號，數值後面直接接 vw 跟 vh。 &lt;tag&gt;:nth-of-type(n)選取器 選取第 n 個同類型標籤的子物件，n 可以是odd、even或是數字。 123.circle:nth-of-type(2){ /* 迭代選擇器，選到第二個點點 */ animation-delay: .1s ;} JS 實現步驟 進入頁面時，假文自 API 取出，出現在頁面。 輸入搜尋字，出現 loading point。 符合搜尋字之內容，排序出來。 showPost() 目的：從 jsonplaceholder API 取得假文。利用 jQuery 版本的 ajax， 什麼是 ajax: 非同步的 JavaScript 與 XML 技術，一種不需要重新整理頁面，透過 JavaScript 跟伺服器交換資料、更新網頁內容的技術。 同步/非同步- 同步是看按照任務順序做，前一個任務完成才會做下一個任務。 - 非同步是，大家一起做，沒有誰先誰後 語法： 1234567891011121314$.ajax({ url:, method:, dataType:, data: success:function(res){console.log(res)}, error:function(err){console.log(err)},});//url: 要請求資料的網址//method: 請求資料的方式(Ex:POST / //GET / PUT...等)//dataType: 請求資料的類型(Ex:xml, json, script, or html...等)//data: 如果需要傳送資料時，則將資料設定在這裡。 本次例子程式碼，先利用 console.log 看看 data 是否取出成功。 123456789101112let limit = 5let page = 1 $.ajax({ url: `https://jsonplaceholder.typicode.com/posts? _limit=${limit}&amp;_page=${page}`, method: 'get', dataType: 'json', success: function (data) { console.log(data); } }) 取出成功 將取出來的資料，使用 forEach，遍及每筆資料，利用 jQuery 創造元素的方式$('&lt;div&gt;&lt;/div&gt;')，加上屬性將取出之假文資料放入設定內容。 123456789data.forEach(function(post){ const postEl = $('&lt;div&gt;&lt;/div&gt;').addClass('post'); postEl.html(` &lt;div class=&quot;number&quot;&gt;${post.id}&lt;/div&gt; &lt;div class=&quot;post-info&quot;&gt; &lt;h2 class =&quot;post-title&quot;&gt;${post.title}&lt;/h2&gt; &lt;p class = &quot;post-body&quot;&gt;${post.body}&gt;&lt;/p&gt; &lt;/div&gt; `) scroll event 設定條件:當整個頁面(widtj 的滾動距離 + 目前顯示視窗的高度 &gt; (整個頁面的高度 - 5)在接近底部時，出現 loading point 並觸發函式showPost()繼續產生假文 12345$(window).scroll(function(){ if ($(document).scrollTop() + $(window).height() &gt; $(document).height() - 5) { showLoading(); }}) 元素的寬度/高度圖片來自：https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements 絕對位置 offsetWidth/ offsetHeight：元素本身+邊界+padding+捲軸 client：元素裡的==子元素==的寬高 +padding (!沒有邊界跟捲軸) scroll：元素內的子元素的寬高，要是子元素超出捲軸外，也包含超出部分，在沒有捲軸時，scroll 就等於 client 相對位置 offset:元素本身相對於母元素的水平/垂直距離 client: 元素本身內外水平/垂直距離，就是邊界的寬高 scrollTop/ scrollLeft:常用！內容被捲動的距離，內容頂端跟捲軸頂端的相對距離。 scrollTop:表示滾動的高度 scrollTop()-&gt;設定滾動的高度/ 取得滾動的高度 12取得滾動的高度： var scrollTop = document.documentElement.scrollTop setTimeout()設置定時器，等時間倒數完畢，就執行一段函式或程式碼。 語法 123var timeoutID = scope.setTimeout(function[, delay, param1, param2, ...]);var timeoutID = scope.setTimeout(function[, delay]);var timeoutID = scope.setTimeout(code[, delay]); setTimeout 小科普 filterSearch()使用者在 input 輸入搜尋值，會顯示符合搜尋值的 post 出來。 1234function filterSearch(){ const text = $('input').val().toLowerCase(); $('.post').css('display','none') $(`.post:contains('${text}')`).css('display','flex');} contain 小科普 tags: javascript","link":"/2021/01/21/JS%E7%B7%B4%E7%BF%92_%E7%84%A1%E9%99%90%E8%BD%89%E8%BB%B8%E9%A0%81%E9%9D%A2/"},{"title":"JS_練習_記帳本","text":"製作一個記帳簿，可以增加收入及支出，並呈現加總金額。 成品畫面： 成果網頁 功能 每個品項記載名稱及金額，並依照金額給予特定屬性。 單一頁面實現新增、刪除品項及各項加總。 html 中間的 HISTORY 是用容器包覆著ul，每筆新增的項目會表示在ul裡及form 最下面則是用form讓使用者填寫新增的項目。 css 使用變數儲存陰影的設定，可以迅速且方便的取用。 12345:root{ --box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0.24); /*取用時以box-shadow: var(--box-shadow)即可取用*/} 在選擇器上，使用&lt;tag&gt;:first-of-type指的是某父元素下相同型別子元素中的第一個，像是本次div:first-of-type 就是在某父型別下的第一個 div。 first-type-of 小科普 在容器右邊設定邊線，達成中間有分隔線的效果。 123.inc-exp-container &gt;div:first-of-type{ border-right: 1px solid #dedede} 在父元素容器，進行切分，利用 flex 設定為一，使子元素自動平分空間 1234.inc-exp-container &gt;div{ flex: 1; text-align: center;} JavaScript步驟 輸入要新增的內容呈現在上面列表 上面列表內容金額自動加總 金額正數呈現綠色，金額負數呈現紅色 點選刪除鍵，總金額自動計算，列表內容刪除 addItem()使輸入的項目，新增至上方 HISTORY，同時也新增一個刪除按鈕。 將原先li標籤設定 minus 屬性，並設定參數條件，若符合條件，則移除 minus 屬性並新增 plus 屬性。 當選擇在 history 刪除項目時，點選==x==觸發事件，記得要加上last()，不然會把所有輸入的項目都刪掉，不會只刪一個。 last 小科普 append()/ appendTo()兩種方法功能相同，都是將目標加入容器之後但語法不同。 (表達式).append(參數) (加入物（參數)).appendTo(容器(表達式)) 12345678910111213141516171819//add item in historyfunction addItem(name, amount, id ,transactions){ var item_str = '&lt;li class =minus&gt;'+name+'&lt;span&gt;'+amount+'&lt;/span&gt;'+'&lt;button class = &quot;delete-btn&quot; data-id=&quot;'+id+'&quot;&gt;x&lt;/button&gt;'; $('#list').append(item_str) if(amount&gt;0){ $('li').toggleClass('minus') $('li').addClass('plus') } clearForm(); $('.delete-btn').last().click(function(){ $(this).parent().remove(); var id =$(this).data('id'); deleteItemFormLocalstorage(transactions, id); updateValues(); })} append to 小科普 localstorage建立一個變數transactions，將儲存在 localstorage 的資料拉出來，並利用JSON parse()將拉出來的資料轉換成陣列形式。 1var transactions = JSON.parse(localStorage.getItem('myTransactions')) || []; generateID() 產生亂數代表決定我們要在列表新增多少項目。 Math.random():會產生 0~1 間的小數。 Math.floor():會將小數點捨去並回傳小於等於產生的亂數的最大整數。 乘上 100000 倍，代表產生亂數的數量。 123function generateID(){ return Math.floor(Math.random()*1000000)}; clearform ()每當新增項目時(要在 addItem()呼叫它)，會清除使用者輸入欄的值，讓使用者得進行下一次的輸入。 1234function clearForm(){ $('#form').find(&quot;input&quot;).val(&quot;&quot;);} deleteItemFormLocalStorage()設定條件，要是 id 完全符合時，使用 splice()方法，刪除陣列項目，再利用使用JSON.stringify，將資料陣列轉為字串重新更新 localstorage。 splice()小科普 123456789function deleteItemFormLocalstorage(transactions, id){ transactions.forEach(function(item, index, arr){ if(item.id === id){ arr.splice(index, 1); } }); localStorage.setItem('myTransactions', JSON.stringify(transactions));} 123456789101112131415161718var transactions = JSON.parse(localStorage.getItem('myTransactions')) || [];$(document).ready(function(){ if(transactions.length &gt;0){ initHistory(transactions); } $(&quot;#form&quot;).find('button').click(function(e){ e.preventDefault(); var name = $('#text').val(); var amount = $('#number').val(); var id = generateID() addItem(name, amount, id, transactions); //push（）讓陣列可以丟進內容 transactions.push({id: id, name: name, amount: amount}); localStorage.setItem('myTransactions', JSON.stringify(transactions)); updateValues(); })}) updateValue() 處理陣列的金額，利用map()運算回傳新的陣列 每一筆交易加總，使用reduce()方法，抓取每一項目的金額進行加總 reduce() 123const sum = array.reduce((accumulator, element) =&gt; { return accumulator + element;}, 0); reduce()小科普 計算收入/ 支出/ 總數金額，使用filter()方法，設定函式計算，經過運算，回傳新的陣列。 filter() 得到元素/ 物件集合中的符合的表達式，把要的物件/元素選出來 12345678&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt; &lt;li&gt;list item 6&lt;/li&gt;&lt;/ul&gt; 1$('li').filter(':even').css('background-color', 'red'); 那選出來的元素會是索引號為偶數得物件，然後我們用 css 讓他變紅色 filter()小科普 加入內文至選定的元素 在函式 initHistory 及點擊事件時呼叫他，使事件發生時能更新資訊。 1234567891011121314151617181920212223242526272829303132333435363738394041function updateValues() { const amounts = transactions .map(function(transaction) { return transaction.amount; }) // reduce()方法：累加陣列中數值 const total = parseFloat(amounts .map(Number) //單純的amount是字串陣列 .reduce((function(accumulator, item_str) { return accumulator += item_str; // accumulator = accumulator + item; }),0)) .toFixed(2); // console.log(total) // filter()方法： 經過內部函式處理後，將通過之元素回傳為新陣列 // https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/filter const income = parseFloat(amounts .filter(function(item_str) { return item_str &gt; 0; }) .reduce((function(accumulator, item_str) { return accumulator -= item_str; }),0))*-1 .toFixed(2); console.log(income) const expense = parseFloat((amounts .filter(function(item_str) { return item_str &lt; 0; }) .reduce((function(accumulator, item_str) { return accumulator -= item_str; //acc=acc-item }),0) * -1)) .toFixed(2); // console.log(expense) $('#balance').text(`$${total}`); $('#money-plus').text(`$${income}`); $('#money-minus').text(`$${expense}`);} initHistory()用 forEach()方法跑一次物件的資料，等呼叫函式時，可以直接顯示。 123456function initHistory(transactions){ transactions.forEach(function(item){ addItem(item.name, item.amount, item.id, transactions)//item.id也要記得加 }) updateValues();} tags: javascript","link":"/2021/01/17/JS%E7%B7%B4%E7%BF%92_%E8%A8%98%E5%B8%B3%E6%9C%AC/"},{"title":"JS_練習_電影院選位頁面","text":"製作一個電影訂位的網頁，可以透過選取的座位數以及不同的電影，呈現不同的票價。 最終畫面呈現： 成果網頁 成品功能 可以選擇不同電影 可以選擇座位 加總選取座位配合搭配電影的票價獲得消費總額 頁面重新整理時，資料保有在原始頁面 HTML 用 select and option 做出下拉式選單，並在 option 後帶入代表票價的 value 123456789&lt;div class=&quot;movie-container&quot;&gt; &lt;label&gt;Pick a movie:&lt;/label&gt; &lt;select id=&quot;movie&quot;&gt; &lt;option value=&quot;10&quot;&gt;Avengers: Endgame ($10)&lt;/option&gt; &lt;option value=&quot;12&quot;&gt;Joker ($12)&lt;/option&gt; &lt;option value=&quot;8&quot;&gt;Toy Story 4 ($8)&lt;/option&gt; &lt;option value=&quot;9&quot;&gt;The Lion King ($9)&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 用 ul 及 li 做出座位狀態表，再利用容器 div 給予屬性裡面包覆很多小容器代表座位。 123456789101112131415161718192021222324252627&lt;ul class=&quot;showcase&quot;&gt; &lt;li&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;small&gt;N/A&lt;/small&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;seat selected&quot;&gt;&lt;/div&gt; &lt;small&gt;Selected&lt;/small&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;seat occupied&quot;&gt;&lt;/div&gt; &lt;small&gt;Occupied&lt;/small&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;screen&quot;&gt;&lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat occupied&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat occupied&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;/div&gt; 利用標籤 p 做出選取的座位數及票價的文字呈現，並利用 span 標籤讓帶入 JS 時可以更方便選取。 123456&lt;p class=&quot;text&quot;&gt; You have selected &lt;span id=&quot;count&quot;&gt;0&lt;/span&gt; seats for a price of $&lt;span id=&quot;total&quot; &gt;0&lt;/span &gt;&lt;/p&gt; CSS網頁整體以 flex 為主，只要設定致中，版面設置滿版 appearance 由於不同瀏覽器的支援不同，針對不同瀏覽器的預設樣式修正。 macOS使用的safari需要-webkit-appearance: none;來防止預設的瀏覽器樣式。 12345.movie-container select { -moz-appearance: none; -webkit-appearance: none; appearance: none;} 先設定好選擇好的座位及特定的座位的 css，就算一開始 html 沒有在標籤內填入這些屬性也可之後ＪＳ帶入時，直接更改 classname 就可套用設定好的 css。 12345678910111213141516171819202122232425.seat.selected { background-color: #6feaf6; /*已選擇座位顏色*/}.seat.occupied { background-color: #fff;}.seat:nth-of-type(2) { /*利用特定位置選擇器做出走道*/ margin-right: 18px;}.seat:nth-last-of-type(2) { /*利用特定位置選擇器做出走道*/ margin-left: 18px;}.seat:not(.occupied):hover { /*選擇器 =&gt; 未被選擇座位碰觸時放大*/ cursor: pointer; transform: scale(1.2);}.showcase .seat:not(.occupied):hover { /*選擇器 =&gt; 上方示意區域取消效果*/ cursor: default; transform: scale(1);} 電影螢幕透過 css 3D 透視效果及搭配本身螢幕容器設定transform:rotate屬性及box-shadow屬性做出類似電影院的效果 12345678910111213.container { perspective: 1000px; /*3D效果*/ margin-bottom: 30px;}.screen { background-color: #fff; height: 70px; width: 100%; margin: 15px 0; transform: rotateX(-45deg); box-shadow: 0 3px 10px rgba(255, 255, 255, 0.7);} JS 宣告變數，要是變數之後還會改變，就會利用let 12let ticketPrice = +$('#movie').val();//jquery沒有'.value&quot; 只有val()let seats = $('.row .seat:not(.occupied)'); 用 click 事件呼叫 callback function，且利用toggle屬性，將參數未有的標籤加上，有的標籤去除。 用 click 事件方式呼叫 callback function 用.target 得到元素並用toggle() 判斷在函式中判斷參數是否含有某 class。target 小科普 用 if 條件判斷符合，就可以在使用 toggle()加入 selected 屬性使他變色 最後呼叫一次updateSelectedCount() 函式，讓我們每產生點擊事件一次，即可更新下方文字敘述。 123456789$(document).ready(function(){ $('.container').click(function(e){ if(e.target.classList.contains('seat') &amp;&amp; !e.target.classList.contains('occupied')){ e.target.classList.toggle('selected'); //因為用toggle 會把沒有的變成有，若有的就會變沒有 updateSelectedCount(); } });}); 使用者可以自由選擇座位，但已選的不能選 編寫步驟如下： 把選取的座位放到 arr 用 map()方法更新 arr 在 return 到新的 arr 利用...運算來將我們選取的位置傳入[]成為陣列array， 利用map()這個方法處理陣列中的元素，返回我們選取的位置在陣列中的索引值(在陣列中哪個位置，從零開始，利用indexOf()方法)。 將取得的索引值存入localStorage，給定兩個參數（keyName, keyValue)，第一個參數作用是給定名稱，稱為keyName(鍵名) =&gt; 下面這個例子叫做selectedSeats第二個參數作用是給定值，稱為keyValue(鍵值)也就是這個keyName對應的值。但keyName和keyValue都必須是字串型別，所以用JSON.stringify()將陣列轉成字串型別。LocalStorage 筆記傳送門 1234567891011121314151617function updateSelectedCount(){ $(document).ready(function(){ const selectSeats = $('.row .seat.selected'); const selectedSeats = $('.row .seat.selected'); const seatsIndex = [...selectedSeats].map(function(seat){ return [...seats].indexOf(seat); }) localStorage.setItem('selectedSeats', JSON.stringify(seatsIndex)); const selectedSeatsCount = selectSeats.length; $('#count').text(selectedSeatsCount); $('#total').text(selectedSeatsCount * ticketPrice) ; }); 使用者可以選擇電影，帶入不同的價格 123456$('#movie').change(function(e){ ticketPrice = $(e.target).val(); setMovieData(e.target.selectedIndex, $(e.target).val()); //這個selectedIndex在哪 updateSelectedCount();}) 每選一個位置，位置圖下有數量跟座位數的正比關係 123456789101112131415161718 function updateSelectedCount(){ $(document).ready(function(){ const selectSeats = $('.row .seat.selected'); const selectedSeats = $('.row .seat.selected'); const seatsIndex = [...selectedSeats].map(function(seat){ return [...seats].indexOf(seat); }) localStorage.setItem('selectedSeats', JSON.stringify(seatsIndex)); const selectedSeatsCount = selectSeats.length; $('#count').text(selectedSeatsCount); $('#total').text(selectedSeatsCount * ticketPrice) ; });} 使用 local Storage 儲存已選的座位，並將其取出後附加屬性 為了使頁面重整後依然能夠保有選取的位置，在每次選取時將內容儲存至瀏覽器的儲存空間，需要時再取出套用其他屬性。 使用 JSON.parse 把 JSON 資料轉換 array 回來，使用 getItem 到我們要使用的 key(selectedSeats)取得 value 並且指派給變數 selectedSeats 使用兩個判斷式 第一個判斷式：條件為selectedSeats不為空值，且localStorage至少需要一個值。 通過第一個判斷式會透過each()方法，檢查selectedSeats索引值是否存在其中。 第二個判斷式：要是透過indexOf()確認索引值存在其中，indexOf 會大於-1 通過第二個判斷式就會加上屬性selected 1234567891011121314151617 const selectedSeats = JSON.parse(window.localStorage.getItem('selectedSeats')); //將localStorage的資料加入 selected屬性 if(selectedSeats !== null &amp;&amp; selectedSeats.length &gt;0){ seats.each(function(index, seat){ //indexOf&gt; -1代表該資料在arr 中 if(selectedSeats.indexOf(index)&gt;-1){ seat.classList.add('selected'); } }); }// 在jquery裡 foreach的方式是 .each(function(index,element))和JS相反，js是foreach(function(element, index)) const selectedMovieIndex =window.localStorage.getItem('selectedMovieIndex'); if(selectedMovieIndex !== null){ $('#movie').selectedIndex = selectedMovieIndex; };} tags: javascript jQuery","link":"/2020/12/05/JS%E7%B7%B4%E7%BF%92_%E9%9B%BB%E5%BD%B1%E9%99%A2%E8%A8%82%E4%BD%8D%E9%A0%81%E9%9D%A2/"},{"title":"JS_練習_音樂播放器","text":"建立一個音樂播放器使使用者能自由播放音樂，選取想要播放的音樂位置，調整音量及曲目。 成品頁面 成品功能 播放/ 暫停音樂 選擇前一首歌/ 下一首歌 使用者可以調整歌曲音量 根據總曲目數量，設定條件讓歌曲循環播放 設定進度條，使使用者決定歌曲的播放位置 HTMLaudio使用 audio 標籤並放上 src，讓網頁能夠輕鬆載入音樂檔 csstranform: translate透過給定目標位置距離起始元素的 left(x 座標)&amp;top 距離(y 座標)，使元素從其當前位置移動。 1transform: translate(50px, 100px); width: 用來控制網頁元素寬度- auto:自動判斷網頁元素的寬度。 - 數字＋單位：可接受的單位有 px, em, cm 等網頁標準單位 - ％：利用百分比設定網頁元素寬度，需要有比較的參考 - inherit：繼承自父層的寬度屬性值。（IE不支援） animation: 設定動畫 animation 常見屬性： animation-name:動畫名稱 animation-duration：動畫持續時間，預設 0，單位 s 或 ms。 animation-deplay：動畫延遲播放時間，預設 0，單位 s 或 ms。 animation-play-state:動畫播放或暫停狀態，預設 running。其他還有 paused。 animation-iteration-count:動畫播放次數，預設 1。還有==infinite== 重複播放 animation-timing-function:動畫加速度函式，預設 ease。其他還有： linear、ease-in、ease-out、ease-in-out，step-start、step-end、steps(int,start/end)、cubic-bezier(n,n,n,n)。 123/*----------可用縮寫--------------*/animation:name duration | timing-function | delay | iteration-count | play-state; 在設定好動畫屬性時，設定關鍵影格 keyframe，可以使用 from…to… 也可以使用 0%~100%設定 123456789@keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } z-index 利用 z-index 屬性，將選取的元素往上排列顯示，z-index 值會大代表越上層。 ==注意==使用 z-index，其元素必須也設定 position，不然 z-index 會沒效果。 123456.bg-image{ width: 100%; height: 100vh; position: absolute; z-index: -1;} z-index 小科普 object-fitobject-fit 屬性使元素去適應定義好寬高的&lt;html 標籤&gt;。本次例子使用該屬性，讓歌曲圖片可以更適應容器 常見的屬性： fill: 預設的效果，也就是圖片會變得跟框框一樣大且若跟保留的框框比例不一樣會變形。 contain: 圖片完整且剛好放進去。 cover: 圖片剛好填滿。 none: 圖片不做縮放但還是限制在框框的範圍。 12345678.bg-image img{ width: 100%; height: 100vh; filter: blur(6px); top: 0; left: 0; object-fit: cover;} object-fit 小科普 JS實現步驟： 點擊按鈕播放歌曲，再次點擊按鈕，暫停歌曲。 點擊按鈕可選擇往前一首曲目或往後一首曲目。 利用音量進度條，調整曲目的音量。 利用歌曲進度條，調整曲目的不同資訊。 loadSong() 將設定好的歌單及作者陣列作為參數執行函式 索引值要試先設定好，作為陣列索引值 利用text()方法顯示歌曲名稱/ 演唱者 設定歌曲的來源、圖片隨著陣列的索引值變動 1234567function loadSong(song,a){ title.text(song); artist.text(a); audio.src = `music/${song}.mp3`; cover.src = `images/${song}.jpg`; bgCover.src = `images/${song}.jpg`;} play() / pause() 透過點擊 button 觸發播放歌曲函式，使其addclass('play')增加 play 屬性，pause()則是removeClass，帶入已設定好的 css 設定。 透過 find()方法找到包含('i.fas')的元素。 移除('fa-play')屬性 增加('fa-pause')屬性 利用audio.play()播放音樂，暫停音樂則是audio.pause()。 123456function playSong(){ musicContainer.addClass('play') playBtn.find('i.fas').removeClass('fa-play'); playBtn.find('i.fas').addClass('fa-pause'); audio.play();} prevSong()/ nextSong() 利用每點擊一次 prevBtn，觸發函式，讓 songIndex 減一 設定條件讓 songIndex 不會一直小下去，因為原本的歌曲陣列 songIndex 只有 0、1、2 執行loadSong()讓曲目圖片改變歌曲也改變 執行playSong()播放歌曲 12345678910111213prevBtn.click(function(){ prevSong();})function prevSong(){ songIndex--; //不然index會一直小下去但原本的index只有 0,1,2 if(songIndex&lt; 0){ songIndex = songs.length -1 } loadSong(songs[songIndex]); playSong()} setProgress()目的：點擊進度條，可以選取所選歌曲的播放位置。 123456789101112progressContainer.click(function(){ setProgress();})function setProgress(){ const width = this.clientWidth; // console.log(width); const clickX = e.offset().left; // console.log(clickX); const duration = audio.duration; audio.currentTime = (clickX/width) *duration;} timeupdate event目的：隨著歌曲的播放更新進度條的寬度，以設置寬度百分比的方式顯示在 progress bar。 觸發時點 播放 video/ audio 時，video/ audio 的播放位置改變時。 currentTime： currentTime 屬性 -&gt;讀取 video/ audio 的播放位置。 duration： duration 屬性返回當前 audio/ video 的長度，以秒計算。 progressPercent： 按照當前歌曲播放的進度佔總歌長的比例。 1234567// timeupdate event$('#audio').on('timeupdate', function() { const duration = $('#audio')[0].duration const currentTime = $('#audio')[0].currentTime const progressPercent = (currentTime / duration) * 100; $('#progress').css('width', `${progressPercent}%`) /*% 不要忘記*/}) tags: javascript","link":"/2021/07/01/JS%E7%B7%B4%E7%BF%92_%E9%9F%B3%E6%A8%82%E6%92%AD%E6%94%BE%E5%99%A8/"},{"title":"git 常用指令","text":"git v.s github 簡介與實作學習目標 什麼是 git 安裝 git git 常用指令 什麼是 github 認識 github，註冊 gitub 帳號 產生 ssh key 上傳到 github，讓 github 認識你的電腦 github 上創造一個 Repository（repo) 什麼是 github? 什麼是 git git 是個軟體 用 command line 操作 可以讓多個開發者一起開發協作 是個分散式版本控制系統， 讓你回到歷史紀錄的某一時刻 因為每次不論由 computerA 或 computerB 的提取及操作，都是將那個版本直接 copy 下來，所以只要任何一處協同工作用的伺服器發生故障，事後都可以用任何一個本地倉庫進行恢復。 圖文網址：https://kknews.cc/code/4vvmvv.html git 常用指令command line 常用指令傳送門 安裝 git 利用 mac 本身的開發者工具 點進去，輸入brew install git github 是個服務 可以上傳你的程式碼 註冊 gitub 帳號前往官網 註冊帳號 產生 ssh key 並上傳到 github首先在終端機先輸入cd(到 user 那) -&gt; pwd（確認是真的是 user) 先產生一個名為.ssh的資料夾，在終端機輸入mkdir .ssh 前往該資料夾，cd .ssh ssh-keygen -t rsa -C &quot;xxx@xxxxxx.com（自己的email）&quot;(產生自己的公鑰跟私鑰) 輸入cat id_rsa.pub(cat 公鑰，通常是把 cat 公鑰產生出來的碼貼到 github 上) 打開 github -&gt; setting -&gt; ssh key 把公鑰貼過來並給他一個名字 github 上創造一個 Repository（repo) 創造一個 repo點選上面的＋，選擇 new repository 輸入你的 repo 的名稱，可以選擇將這個公開與否） 回到 iterm 要是本地電腦 尚未有 專案資料夾選擇 creat a new repository on the command line操作 要是本地電腦已有專案資料夾 選擇 push an existing repository from the command line操作 tags: git","link":"/2020/11/08/git%20v.s%20github%E7%B0%A1%E4%BB%8B%E8%88%87%E5%AF%A6%E4%BD%9C/"},{"title":"git 常用指令","text":"git add 表示把檔案加入暫存區，交給 git 操控。 Ex. 要是我想把 abc.txt 這個檔案加到 git_demo 這個資料夾， 先 cd 到目的地資料夾，在輸入git add &quot;abc.txt&quot;就可以在用git status確認是否真的加入了 git commit 提交版本 當你不論對檔案做新增修改任何動作時，其實只是先將檔案放入暫存區，需要 git commit 後才是真正的將檔案提交至倉庫存放。 寫法：git commit -m &quot;提交版本的資訊&quot; 延續上一個 Ex. 我們新增了一個 abc.txt 檔案，接著我們輸入git add -m &quot;add abc.txt&quot; git push 推送更新遠端資料庫 將更新後的資料推送更新至遠端的 git 伺服器資料庫 延續上一個 Ex. 我們新增了一個 abc.txt 檔案，也將檔案提交至倉庫存放了，接著我們在網頁上的 github 創建了一個 repo(git_demo)，之後我們準備將檔案更新至 git 伺服器資料庫上。 前往 github 網頁創造一個 repo，假設 repo 名稱為 git_demo 回到 vscode 輸入git remote add origin git@github.com:Chrislinlin/git_demo.git 輸入 git push -u origin master 成功將 abc.txt 檔案推送給 github 上的遠端資料庫 git clone/pull取得 repo 使用時機：在 git 上看到有趣的專案，想要把他載到本地端電腦 探討 git clone/ git pull 使用時機 進入&lt;專案&gt;裡，點選 code，將連結複製起來 回到 iterm，先 cd 存放專案的目的地資料夾 輸入 git clone git@github.com:Chrislinlin/cinnamon.git 目的地資料夾已成功載入專案內容 git clone/ pull 差別 要是第一次看到有趣的專案要載下來，請用 git clone 要是第二次以上要 renew，請用 git pull git rm 刪除檔案 寫法： git rm '要刪掉的檔案' ex. 我們要將 abc.txt 這個檔案給刪掉。 cd 到目的地資料夾後輸入 git rm abc.txt git mv 修改檔案名字 寫法： git mv '舊名字' '新名字' ex. 我們要將 abc.txt 名字改成 def.txt。cd 到目的地資料夾後輸入 git mv abc.txt def.txt 檔案名字就從 abc -&gt; def git merge git branch查看/ 創造分支 查看分支 寫法：git branch &quot;分支名稱&quot; 創造分支 寫法：git branch &quot;分支名稱&quot; ex. 先輸入 git branch 查看目前有什麼分支 目前只有 master 這個分支 輸入git branch newDemo創造一個 newDemo 的分支在用git branch查看，確定分支已被創造 git checkout 切換分支 寫法： git checkout '要切換的分支' ex. 從 master 分支 要切換為 newDemo 分支 輸入 git checkout newDemo就轉換成功了。 ==組合技== 寫法：git checkout -b&quot;要創造的branch這個方式直接把git branch + git checkout加在一起，可以直接在 A 分支，立刻創造 B 分支並切換到那去。 tags: git","link":"/2020/11/07/git%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"title":"Hexo 筆記一","text":"hexo 系統是採用以 md 檔發佈至部落格， 安裝步驟 確認電腦已安裝 node.js git 使用 npm 下載 hexo 1$ npm install hexo-cli -g npm 是什麼？npm 為 Node Package Manager 的縮寫，開發者可以透過 Node 隨 附的 npm cli，進行套件的安裝及管理。 初始化資料夾(假設以blog作為資料夾名稱命名) hexo 初始化 進入該資料夾(blog) npm install 12345$ hexo init$ cd blog$ npm install 安裝完成使用 vscode 打開，左邊應該會出現如下圖所示，請忽略 icarus 及 landscape 主題，這是我之後去安裝的，預設只有config.yml 使用本地端開啟部落格網頁在 terminal 輸入指令 1$ hexo server //可以縮寫 hexo s 發布文章 下載 Markdown 檔 先到 hackMD，把之前已寫好的筆記下載至本地端(hackMD 是個可以線上操作記錄筆記網站，也可將筆記檔(.md 檔)下載至本地端) 下載方式如下: 在本地端在 blog 資料夾內層中找到_posts 資料夾，並將.md 檔案拖曳至於其中 輸入hexo g || hexo generate 接著輸入 hexo s || hexo sever 使狀態回到 localhost:4000，預覽部落格的狀態 再輸入 hexo d || hexo deploy 刪除文章 進入本地端存放 md 檔的資料夾source / _post 中，找到欲刪除的文件，在本地直接執行刪除。然后依次執行指令 12hexo ghexo d 再去主頁查看，就會發現发现部落格上你所要刪除的文章已消失無蹤了。 tags: Hexo","link":"/2021/04/02/Hexo%20%E7%AD%86%E8%A8%98%E4%B8%80/"},{"title":"Hexo 筆記二","text":"常用指令hexo g產生靜態檔案，會於目錄下產生 public 資料夾。 1$ hexo generate || hexo g hexo s啟動伺服器，預設是 http://localhost:4000/。 1$ hexo server || hexo s hexo d部署網站。（ 比如把網頁推上 github 平台） 1$ hexo deploy || hexo d ==超常用縮寫组合== 123$ hexo d -g 產生靜態檔後部署$ hexo s -g 產生靜態檔後預覽 端口被佔用 出現的錯誤訊息代表端口 4000 port 被佔用了，所以無法以hexo server去顯示部落格。 解決方法 找到對應的端口 1sudo lsof -i:port # port為對應的端口 我們知道端口是被 PID 10247 所佔領 把佔領的 PID 殺了 1sudo kill -9 10247 #上面顯示的PID 即可成功執行 hexo server 1hexo server hexo 資料同步其他台電腦就算有把原本在 a 電腦的全部 hexo 資料，複製到 b 電腦，在 b 電腦也無法執行 hexo 解決方法 確認另外一台電腦有沒有安裝 npm 輸入指令 1npm install hexo-cli -g tags: Hexo","link":"/2021/04/02/Hexo%20%E7%AD%86%E8%A8%98%E4%BA%8C/"},{"title":"Hexo 筆記三","text":"推上 github 先在 github 新增一個 repository，命名邏輯為 12github ID名稱.github.io例：Chrislinlin.github.io 複製該 repository 的網址(例：git@github.com:Chrislinlin/Chrislinlin.github.io.git) 用 vscode 編譯器，打開_config.yml 檔案，修改deployment的部分 1234deploy: type: git repo: https://github.com/Chrislinlin/Chrislinlin.github.io branch: main 安裝 git 部署套件 1$ npm install hexo-deployer-git --save 輸入指令，將網站佈署到伺服器上 1$ hexo deploy -g 設定 repository 的主題在 github 的該 repository 頁面，進入「setting」往下滑，點按「change theme」 在瀏覽器中查看網址，成功的看到部落格推上去！https://Chrislinlin.github.io/ 若有檔案更新，則重複輸入指令 1hexo deploy -g 更換主題 尋找前往hexo 主題官網尋找有興趣的主題 安裝 前往該主題的 github 頁面，勇敢的 git clone 他，這裡示範安裝 icarus 主題 在 vscode 開啟當初創建部落格資料，輸入指令 clone 想要安裝的主題 1git clone https://github.com/ppoffice/hexo-theme-icarus.git 修改_config.yml原本內建的主題是landscape，這裡修改為 icarus 重新產生專案 1hexo g 完成 tags: Hexo","link":"/2021/04/02/Hexo%E7%AD%86%E8%A8%98%E4%B8%89/"},{"title":"Pseodo Code(虛擬碼)","text":"它以程式語言的書寫形式指明演算法的職能。相比於程式語言（例如 Java、C++、C、Delphi 等等）它更類似自然語言。它是半形式化、不標準的語言。我們可以將整個演算法執行過程的結構用接近自然語言的形式（這裡可以使用任何一種作者熟悉的文字，例如中文、英文，重點是將程式的意思表達出來）描述出來。使用虛擬碼，可以幫助我們更好的表述演算法，不用拘泥於具體的實現。維基小科普 思考步驟 先腦袋想一下這個大問題，將大問題分割成很多個小問題 一行只做一件事 善用敘述、條件判斷 要是有需要重複執行的情況，利用跳轉（jump）來實現重複執行 練習wordLength()得到字串長度的 wordLength() 函式 預期 pen 的字串長度為 3 預期 apple 的字串長度為 5 預期 Pineapple 的字串長度為 9 預期 古坂大魔王 的字串長度為 5 123456- PseudoCode :1. 宣告 input 為 要輸入的單字 // 設置初始條件2. 建造 func wordLength(input): //建立測試函式，決定回傳值 得到 input.length;3. wordlength(input);//執行函式 LowerCase()將單字變成小寫 wordLowerCase() 函式 5) 預期大寫的喵變成小寫的喵 CAT 變成 cat 6) 預期 Tea 變成 tea 123456- PseudoCode :1. 宣告 input 為 要輸入的單字 // 設置初始條件2. 建造 func wordLowerCase(input): //建立測試函式，決定回傳值 得到 input ← lower(input)3. wordLowerCase(input)//執行函式 UpperCase()將單字變成大寫 wordUpperCase() 函式 7) 預期 Dog 變成 DOG 8) 預期 hello world 變成 HELLO WOLRD 123456- PseudoCode :1. 宣告 input 為 要輸入的單字 // 設置初始條件2. 建造 func wordLowerCase(input): //建立測試函式，決定回傳值 得到 input ← Upper(input)3. wordUpperCase(input)//執行函式 getLastCharacter()取得最後一個字元 getLastCharacter() 函式 預期 Pen 的最後一個字元為 n 預期 Pencil 的最後一個字元為 l 預期 Monday 的最後一個字元為 y 12345- PseudoCode :1. 宣告 input 為 要輸入的string // 設置初始條件2. 宣吿得到input string的長度;3. 將字串變成一個個字符，利用索引值取出4. 放入index.html tags: pseudocode","link":"/2021/04/03/Pseodo%20Code(%E8%99%9B%E6%93%AC%E7%A2%BC)/"},{"title":"W3C DOM 簡介","text":"DOM 是什麼？ DOM 是 Document Object Model 的縮寫 是一個文件樹 W3C 當初為解決各大瀏覽器間物件標準不一致時，所制定的一個新的標準物件模型，在這標準下，一個物件所有的標籤定義，包含每一個文字，都是一個物件，這些物件會組成一個樹狀結構。 例子： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM World&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello!World!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 圖片來源 文件從根元素開始，包含許多子元素。 文件上的標籤元素或是文字都是文件樹上的一個==節點==(Node 的物件) 常見的節點型態有許多種，某些特定的節點物件是哪一種節點會紀錄在該節點物件的 nodeType 屬性 文件物件的方法文件可以動態產生節點 document.creatElement(tagName) 建立一個標籤名成為 tagName 的元素 如：document.createElement(‘div’); document.creatTextElement(text) 建立一個文字的節點 如：document.creatTextElement(‘Hello, World!’);` 文件屬性 屬性名稱 說明 childNodes 傳回目前元素所有子節點的節點清單 firstChild 傳回目前元素的第一個子節點 lastChild 傳回目前元素的最後一個子節點 nextSibling 傳回緊鄰目前元素 後 的節點 presviousSibling 傳回緊鄰目前元素 前 的節點 parentChild 傳回元素的父節點 nodeName 傳回節點的名稱 nodeType 傳回節點的型態 nodeValue 傳回節點的值 節點方法 node.appendChild(childNode) 將指定的子節點附加在 node 的子節點清單的最後面 如：div.appendChild(span); node.removeChild(childNode) 將指定的子節點從 node 中刪除 如：div.removeChild(span); node.replaceChild(Anode, Bnode) 將 node 子節點中，把 b 節點換成 a 節點 如：div.replaceChild(aSpan, bSpan); node.hasChildNodes() 判斷是否有子節點 如：div.hasChildNodes(); 元素物件節點方法 element.getAttribute(attributeName) 取得元素中，某屬性的值 如：div.getAttribute(“class”); element.setAttribute(attributeName, value) 設定元素中，某屬性的值 如：div.setAttribute(“class”,”item”); element.removeAttribute(attributeName) 設定元素中，某屬性的值 如：div.removeAttribute(“item”); element.getElementByTagName(tagName) 取得元素中名稱為 tagName 的所有子元素 如：div.getElementByTagName(tagName); tags: javascript","link":"/2021/04/03/W3C%20DOM%20%E7%B0%A1%E4%BB%8B/"},{"title":"bootstrap","text":"由 HTML、CSS 和 JavaScript 寫成的前端框架，設計核心為達成 RWD 響應式頁面，也就是讓你的網站可以自動排版，目前已出到 bootstrap 5，。 導入 在 css 裡貼上 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot;&gt; 在 javascript 裡貼上 1&lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js&quot; integrity=&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; 當然你也是可以把版本載到本機下來用連結的 通用格式有時候我們把很多個 bootstrap 樣版貼上來，但大家都會黏在一起，當又懶得去設定個別的 css 時，可以使用 bootstrap 內建的 css 設定去調整不同元素的空間距離及顏色呈現。 Spacing 使用在 css 熟悉的margin及padding 123456789m：marginp：paddingt：topr：rightb：bottoml：leftw: widthx：-right和-lefty：-top 和 -bottom 組合技 12345678910111213141516m：marginmt：margin-topmr：margin-rightmb：margin-bottomml：margin-leftmx：margin-right 和 margin-leftmy：margin-top 和 margin-bottomp：paddingpt：padding-toppr：padding-rightpb：padding-bottompl：padding-leftpx：padding-right 和 padding-leftpy：padding-top 和 padding-bottomw-100: width:100% 數字bootstrap 數字代表間距的意思。數字 1 代表 0.25rem 而 1rem = 16pxmb-5 = margin-bottom: 3rem(48px) 起手式-建置隔線系統123456789101112131415161718192021&lt;!---隔線系統容器--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;!---資料容器--&gt; &lt;div class=&quot;text&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit, amet consectetur laudantium. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;!---資料容器--&gt; &lt;div class=&quot;text&quot;&gt; &lt;p&gt;Lorem ipsum dolor sit, amet consectetur laudantium.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 建立一個容器container，在要執行的內容都丟到容器裡 container 容器有分二： 固寬容器：固定寬度的容器，內建在不同裝置下他會有不同的寬度&lt;div class =&quot;container&quot;&gt; 非固定寬度容器（滿版）：&lt;div class =&quot;container-fluid&quot;&gt;滿版 在這 container 容器裡，再建立一個 row 容器 &lt;div=&quot;row&quot;&gt; row容器裡，設定需要的欄位數。在 row 裡在加入名為 col-(斷點代碼)-(格數) 的 class 來進行，例如媒體寬度在 ≥768px 時，格數要佔 3 格時則寫 col-md-3。 Bootstrap 所預設的格線數為 12，把一行 row 分成 12 等份，依照想要的寬度去決定尺寸代號，分幾等分。 尺寸代碼： Small — sm 576px &lt;= 768px Medium — md 768px &lt;= 992px Large — lg 992px &lt;= 1200px Extra large — xl 1200px&lt;= 例子：要是我們想要把畫面做 RWD 效果時，像是使用螢幕有螢幕的顯示方式，使用平版有平板的及手機有手機的尺寸方式。可以直接添加不同的欄位名稱，並在最後一個欄位新增斷點資訊。&lt;div class =&quot;col-12 col-md-6&quot;&gt; 建立隔線系統有三種 自動隔線系統：使用col，無法折行，假如要改變拆行必須在 row。要是想分五欄的版面就直接 12345678910111213&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;col&quot;&gt;...&lt;/div&gt;&lt;/div&gt;### form-select- 成品![](https://i.imgur.com/MB1YLZW.png) Open this select menu 台北市 桃園市 新竹市 12345678910111213- ·`selected` 一開始預設的選擇- 資料帶入是帶入1 兒不是one### form-上傳選單- 成品 ![](https://i.imgur.com/0aZg7ER.png)```.html &lt;div class=&quot;input-group mt-5&quot;&gt; &lt;label class=&quot;input-group-text&quot; for=&quot;inputGroupFile01&quot;&gt;Upload&lt;/label&gt; &lt;input type=&quot;file&quot; class=&quot;form-control&quot; id=&quot;inputGroupFile01&quot;&gt; &lt;/div&gt; label裡的 for 屬性，一定要跟 input 裡的 id 一致不然會失敗。 Utility-Overflow把超過容器的範圍做隱藏或是顯示或是出現轉軸 1234&lt;div class=&quot;overflow-auto&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;overflow-hidden&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;overflow-visible&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;overflow-scroll&quot;&gt;...&lt;/div&gt; navbar+card 成品 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Navbar&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-bs-toggle=&quot;collapse&quot; data-bs-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt; &lt;ul class=&quot;navbar-nav me-auto mb-2 mb-lg-0&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link active&quot; aria-current=&quot;page&quot; href=&quot;#&quot;&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item dropdown&quot;&gt; &lt;a class=&quot;nav-link dropdown-toggle&quot; href=&quot;#&quot; id=&quot;navbarDropdown&quot; role=&quot;button&quot; data-bs-toggle=&quot;dropdown&quot; aria-expanded=&quot;false&quot;&gt; Dropdown &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;navbarDropdown&quot;&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;hr class=&quot;dropdown-divider&quot;&gt; &lt;/li&gt; &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link disabled&quot; href=&quot;#&quot; tabindex=&quot;-1&quot; aria-disabled=&quot;true&quot;&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;d-flex&quot;&gt; &lt;input class=&quot;form-control me-2&quot; type=&quot;search&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot;&gt; &lt;button class=&quot;btn btn-outline-success&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div class=&quot;container mt-5&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Special title treatment&lt;/h5&gt; &lt;p class=&quot;card-text&quot;&gt;With supporting text below as a natural lead-in to additional content.&lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Go somewhere&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Special title treatment&lt;/h5&gt; &lt;p class=&quot;card-text&quot;&gt;With supporting text below as a natural lead-in to additional content.&lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Go somewhere&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h5 class=&quot;card-title&quot;&gt;Special title treatment&lt;/h5&gt; &lt;p class=&quot;card-text&quot;&gt;With supporting text below as a natural lead-in to additional content.&lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Go somewhere&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; tags: bootstrap","link":"/2021/04/01/bootstrap/"},{"title":"JS_web storage","text":"介紹兩種 web storage 的儲存方式。 型態： localStorage 可以跨瀏覽器分頁做使用、使用者關掉分頁或瀏覽器再打開資料仍不會消失，且資料無期效限制，資料將永久被保留 sessionStorage 當使用者關掉瀏覽器或分頁時，sessionStorage 中的資料將被清空。 資料儲存格式 以 JSON 的 key-value 格式儲存 方式 存入資料 ===setItem()=== 12localStroage.setItem(key, valuesessionStroage.setItem(key, value) 取出資料 ===getItem()=== 1234localStroage.getItem(key, valuesessionStroage.getItem(key, value) 移除資料 ===removeItem()=== 12localStroage.removeItem(key, valuesessionStroage.removeItem(key, value) 找到儲存的資料 console 資料出來後，去開發者工具的 Application 中查看 local Storage。 缺點 儲存容量只有 5mb key-value 只接受==字串== 解決方法：轉換成 JSON 格式的字串 透過JSON.stringify()先轉換成字串，要取出資料時再透過 JSON.parse() 將資料轉換為原本的格式。 tags: javascript","link":"/2021/03/29/JS_web%20storage/"},{"title":"CSS_Note","text":"對於 css 中一些屬性的筆記如下(持續增加中…)。 weight:100% 若沒有給預設值，會自動填滿整個瀏覽器的頁面寬 height:100% 沒有預設值，沒寫就是 null height 的百分比值需要父元素有一個有效的高度值才能起作用-ex.12height: 100%; margin: 0; padding: 0;} box-sizing：border-box 讓你不用手動加減就可以涵蓋 padding+margin 在原本容器尺寸 background-image 插入背景圖片 linear-gradient 漸層 background: linear-gradient(方向/角度, 顏色1 位置(％數), 顏色2 位置(％數)....);) 要是方向沒寫的話，預設為由上往下，若填寫角度則由左下角為圓心順時針旋轉 ex. 1linear-gradient(blue, yellow 30%, blue 90%) position 定位 absolute(絕對定位) 使用absolute屬性定位的元素是以在他所處==上層容器==的相對位置，若沒有上層容器，則以body(螢幕左上角)位置作為相對位置 當畫面在捲動時，有該屬性的元素還是會隨著頁面捲動。 fixed(固定定位) 相對於瀏覽器視窗來定位，即便頁面捲動，它還是會固定在相同的位置。 relative(相對定位) 會使其元素「相對地」調整其原本該出現的所在位置，做出調整。 例子，假設設定兩個帶有顏色的容器， 若增加relative屬性後且給定距原本元素的距離後。 font-weight(文字體粗細)Demo 傳送門 line-height text 裡的行高 transition 動畫 opacity .5s .5s //延長多久 delay 多久 常見屬性 transition-delay transition-duration transition-property transition-timing-function 可以跟 transform 一起搭配 例子假設 html 有一個容器，我們在 css 設定他碰到時容器會以 2 秒時間增長程式碼如下。 123456789div { width: 100px; height: 100px; background: red; transition: width 2s;}div:hover { width: 300px;} transform 2D/3d transform 常見屬性： translate 以原本容器所在處，往 X 或 Y 軸移動， scaleX/scaleY() rotate(角度) 讓容器原地旋轉多少角度，若角度值為負數，則逆時間旋轉，要是角度為負責代表逆時鐘旋轉。 transform:translate z-index 層 只有在設定 position 的元素上會有效 設定值越高越前面，值可以為負數 檢查 被覆蓋的層(想要置頂的層）的 position 是否也為 relative 或者 absolute 如果 1 成立，則判斷是否此層的 z-index 比誤覆蓋的層的 z-index 數值大 如果 2 成立，判斷是否此層的父級元素比誤覆蓋的層的 z-index 數值大 如果 3 成立，判斷是否此層的父級元素比誤覆蓋的層的父級層的 z-index 數值大 overflow 元素要是超出某一範圍時該怎麼辦 常見的值 overflow:auto; //預設會自動使用捲軸 overflow:visible; //顯示的文字或圖片會直接超出範圍，不使用捲軸。 overflow:hidden; //自動隱藏超出的文字或圖片。 overflow:scroll; //自動產生捲軸。 overflow:inherit; //繼承自父元素的可見性。 css 選擇器- 子選擇器(選擇器之間使用&gt;大於符號)選擇父元素的子元素，但不包括子元素的子元素 12&lt;div class=&quot;div1&quot;&gt;&lt;p&gt;div1-P1&lt;/p&gt;&lt;span&gt;&lt;p&gt;div1-P2&lt;/p&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt;&lt;p&gt;div2-P1&lt;/p&gt;&lt;span&gt;&lt;p&gt;div2-P2&lt;/p&gt;&lt;/span&gt;&lt;/div&gt; 123456.div1 &gt; p { color: #F00;}.div2 p { color: #F00;} tags: css","link":"/2020/12/02/CSS%20Note/"},{"title":"JS_練習_Github搜尋器","text":"透過串接製作一個github REST API搜尋器，輸入 github 用戶帳號或是 repo 名稱可以列表將使用者專案數、所屬公司列表追蹤人數列表出來，若是搜尋不到則會觸發告警提示。 成品畫面 功能 呈現使用者資訊(如:大頭照所屬公司專案數目何時加入…. 若搜尋不到輸入資訊，出現告警提示 顯示使用者最新的 repo 在下方，可以透過點擊連結相關網頁 HTML/CSS主要透過 bootStrap 已設定好的樣式呈現。 JSgetUserData()利用ajax串接 API，確認串接網址/資料型態/方式/成功或失敗獲得我們想要的資訊，並在前面取得資料時要是載入錯誤，則會觸發 error 函式，最後呼叫函式顯示在頁面上。 成功：會取得 GitHub 用戶資訊並呼叫showProfile()將取得內容當做函式參數。 失敗：會呼叫showAlert()利用alert alert-danger 的 class 讓其顯示為紅色。 123456789101112131415161718192021222324252627282930function getUserData(){ $.ajax({ //github endpoint url: `https://api.github.com/users/${userName}`, method: 'GET', dataType: 'json', success: function(res) { let obj = {}; obj.avatar_url = res.avatar_url !== null ? res.avatar_url : ''; obj.name = res.name !== null ? res.name : ''; obj.html_url = res.html_url !== null ? res.html_url : ''; obj.public_repos = res.public_repos !== null ? res.public_repos : ''; obj.public_gists = res.public_gists !== null ? res.public_gists : ''; obj.followers = res.followers !== null ? res.followers : ''; obj.following = res.following !== null ? res.following : ''; obj.company = res.company !== null ? res.company : ''; obj.blog = res.blog !== null ? res.blog : ''; obj.location = res.location !== null ? res.location : ''; obj.created_at = res.created_at.substr(0, 10) !== null ? res.created_at.substr(0, 10) : ''; obj.updated_at = res.updated_at.substr(0, 10) !== null ? res.updated_at.substr(0, 10) : ''; showProfile(obj); }, error: function(res) { data = res.responseJSON.message; if (data === 'Not Found') { showAlert(data, 'alert alert-danger'); } } }); getRepoData()同樣利用ajax串接 API，確認連結位置，決定資料型態，取得資料，並在連結成功時，呼叫函式showRepo函式。url 裡的連結網址有設定per_page=5，讓展現搜尋資料時，只會出現五筆資料。 1234567891011function getRepoData(){ $.ajax({ url:`https://api.github.com/users/${userName}/repos?per_page=5&amp;sort=created: asc`, method:'GET', datatype:'json', success: function(data){ getData = data; showRepo(getData); } })} showProfile()在一開始getUserData函式中設定呼叫showProfile()函式，將得到的使用者資料寫入選取容器的 html 裡。 123456789101112131415161718192021222324252627282930313233function showProfile(user){$('#profile').html( `&lt;div class=&quot;card card-body border-0&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;img src=&quot;${user.avatar_url}&quot; class=&quot;img-fluid rounded-circle mb-2&quot;&gt; &lt;h5 class=&quot;mt-2 text-center&quot;&gt;${user.name}&lt;/h5&gt; &lt;a href=&quot;${user.html_url}&quot; target=&quot;_blank&quot; class = &quot;btn btn-primary btn-block mb-4&quot;&gt;View Profile&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-md-9&quot;&gt; &lt;div class=&quot;container mt-2 px-0&quot;&gt; &lt;span class=&quot;badge badge-primary ml-5&quot;&gt;Public Repos: ${user.public_repos}&lt;/span&gt; &lt;span class=&quot;badge badge-secondary&quot;&gt;Public Gists: ${user.public_gists}&lt;/span&gt; &lt;span class=&quot;badge badge-success&quot;&gt;Followers: ${user.followers}&lt;/span&gt; &lt;span class=&quot;badge badge-info&quot;&gt;Following: ${user.following}&lt;/span&gt; &lt;/div&gt; &lt;ul class=&quot;list-group list-group-flush mt-2 ml-5&quot;&gt; &lt;li class=&quot;list-group-item&quot;&gt;Company: ${user.company}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Website/Blog: ${user.blog}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Location: ${user.location}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Member Since: ${user.created_at}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Currently Updated: ${user.updated_at}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;col-md-12&quot;&gt; &lt;h3 class=&quot;page-heading mb-3&quot;&gt;Latest Repos&lt;/h3&gt; &lt;div id=&quot;repos&quot;&gt;&lt;/div&gt;&lt;/div&gt;`)} showRepo()把取得資料利用forEach方式加入至創建好的容器repo裡，並決定其 html 外觀樣式。 1234567891011121314151617181920212223//show repofunction showRepo(repos){ repos.forEach(function(repo){ //把repodata東西加在getRepoData中創建的容器後 const repoData = $('&lt;div class = &quot;card card-body mb-2 border-0&quot;&gt;&lt;/div&gt;').appendTo('#repos'); let repoDes = repo.description !== null ? repo.description : ''; repoData.html(` &lt;div class=&quot;row shadow-sm p-3 bg-white rounded&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;a href=&quot;${repo.html_url}&quot; target=&quot;_blank&quot;&gt; &lt;h3&gt;${repo.name}&lt;/h3&gt; &lt;/a&gt; &lt;p&gt;${repoDes}&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;span class=&quot;badge badge-warning m-1&quot;&gt;Stars ${repo.stargazers_count}&lt;/span&gt; &lt;span class=&quot;badge badge-success m-1&quot;&gt;Watchers ${repo.watchers_count}&lt;/span&gt; &lt;span class=&quot;badge badge-info m-1&quot;&gt;Forks ${repo.forks_count}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; `)} );} showAlert()當使用者輸入資訊在 GitHub 網站找不到時，會秀出紅色示警視窗，並經過設定時間五秒後示警視窗消失。創立變數 alertMessage，設定其元素、屬性及其內容，使用insertBefore在 alertMessage==前==再加上 bootstrap 設定好的屬性，並將搜尋結果欄清空。 1234567891011121314//showalert functionfunction showAlert(message, className){ const alertMessage = $('&lt;div&gt;&lt;/div&gt;').attr('class', className + ' text-center'); alertMessage.text(`User &quot;${userName}&quot; is ${message}`) //insertBefore在現有的子節點前插入一個新的子節點 alertMessage.insertBefore($('.search.card.card-body.border-0')) $('#profile').html(''); //setTimeout 2秒後把alertMessage移開 setTimeout(function(){ alertMessage.remove() },5000)} click event透過在選取的searchBtn點擊後觸發函式，給定 userName 當作參數。 12345678const searchBtn = $('.search-btn');searchBtn.click(function(){ //指定searchUser 的val 給username userName = searchUser.val(); getUserData(userName); getRepoData(userName); searchUser.val('');}) tags: javascript","link":"/2021/02/18/JS%E7%B7%B4%E7%BF%92_Github%E6%90%9C%E5%B0%8B%E5%99%A8/"},{"title":"JS_練習_可排序表單","text":"能夠將電腦亂排順序的名單，自由選取排列，排列正確會變綠色，順序錯誤會是紅色。 純 HTML 畫面 成品畫面 HTML再 HTML 建立空白的無序列表，等 JS 再將內容加至設定好的ul，最後再加上一個button以執行 JS 已確認排序是否正確。 1234567891011&lt;h1&gt;Top 10 Videos on Youtube 2020&lt;/h1&gt;&lt;p&gt;Drag and Drop items into their corresponding spots&lt;/p&gt;&lt;ul class=&quot;draggable-list&quot; id=&quot;draggable-list&quot;&gt;&lt;/ul&gt;&lt;button class=&quot;check-btn&quot; id=&quot;check-btn&quot;&gt; Check Order &lt;i class=&quot;fas fa-paper-plane&quot;&gt;&lt;/i&gt;&lt;/button&gt; CSSbody::after在根元素body後面，透過偽元素選擇器，使整個 body 加上一層半透明的黑影，使畫面看起來質感加分。 123456789body::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); } 偽類常見的偽類樣式： :active:滑鼠按下會產生的狀態。 :focus:鍵盤聚焦會產生的狀態。 :hover:滑鼠滑過會產生的狀態。 :link:還沒訪過會產生的狀態。 :visited:被訪過會產生的狀態。 JS實現步驟 創造一個陣列放入容器，陣列是有索引值與內容。 利用 sort 方法將隨機產生的索引值按照大小排列， Drag and Drog API 創造要丟進 DOM 的陣列 123456789101112- const hottestVideo = [ '羅一鈞副組長', '蔡阿嘎與孕婦二伯', '粿粿-花蓮落下事件', '這群人-請假經典語錄', '黃氏兄弟-我想跟家人說', '中指通的歐美女優精選', '孫生去監獄看媽媽', '狠愛演-謝謝大家', '反正我很閒-卑鄙源之助的一天', '東森51-臨終前最後26秒奮力道別'] creatList() 利用...將陣列展開變成個別的值。 利用forEach()將每個陣列的值，都放到 li 裡，並設定 li 裡的屬性及加上索引值。 填入 HTML 的內容在我們所定義好屬性的陣列裡。 part II: 利用map()方法創造新陣列。回傳 該影片的 value 創造一個 sort，並用Math.random方法隨機產生 0~1 的數字 part III: 利用 sort 方法將 random 出來的數字按照大小排列。 part IV: 再利用 map 方法將我們 part II 產生的 valuesort()小科普 123456789101112131415161718192021222324252627282930313233creatList()//creat List items into DOMfunction creatList(){ [...hottestVideo] //part II .map(function(a){ return{ value:a , sort: Math.random() } })//part III .sort(function(a,b){ return (a.sort - b.sort) })//part IV .map(function(a){ return a.value }) .forEach(function(video,index) { const listItem = document.createElement('li'); //index =0~9 listItem.setAttribute('data-index', index); listItem.innerHTML = ` &lt;span class ='number'&gt;${ index + 1 }&lt;/span&gt; &lt;div class =&quot;draggable&quot; draggable =&quot;true&quot;&gt; &lt;p class =&quot;video-name&quot;&gt;${video}&lt;/p&gt; &lt;i class = &quot;fas fa-grip-lines&gt;&lt;/i&gt; &lt;/div&gt; `; listItems.push(listItem); draggableList.appendChild(listItem); });} 函式外呼叫函式，畫面呈現。 加入 partII/ part III 加入 part IV addEventListener() drag event 小科普 設定 ==drag==事件，其中分為兩項觸發 被選擇的物件。 dragstart 方法就是在物件開始拖曳時觸發。 在觸發事件時利用closest()方法取得當前元素最近得祖先元素，並透過getAttribute得到該元素的indexclosest()小科普 可以當作目標的物件。 dragleave 是當被選擇物件被拖曳到可以當作目標物件的上方時，在離開目標物件上方時，瞬間觸發。 dragover 當被選擇物件被拖曳到可以當目標物件上方時觸發。是目標物件觸發！不是被選擇物件。 drop 當被選擇物件被拖曳到目標物件時觸發。是目標物件觸發！不是被選擇物件。 建立函式swapItem()，利用最上面先建立一個空陣列 listitems。再設立參數並將值選出且利用appendChild賦值，將內容進行交換。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 addEventListeners() });}function dragStart() { // console.log('event: ' , 'drapstart') dragStartIndex = this.closest('li').getAttribute('data-index'); // console.log(dragStartIndex); } function dragOver() { console.log('event: ' , 'drapover') } function dragDrop() { // console.log('event: ' , 'drapDrop') const dragEndIndex = +this.getAttribute('data-index') swapItems(dragStartIndex, dragEndIndex); this.classList.remove('over'); } function swapItems(fromIndex, toIndex){ // console.log(124); const itemOne = listItems[fromIndex].querySelector('.draggable') const itemTwo = listItems[toIndex].querySelector('.draggable'); // console.log(itemOne, itemTwo); listItems[fromIndex].appendChild(itemTwo); listItems[toIndex].appendChild(itemOne); } function dragLeave() { console.log('event: ' , 'dragleave') } function dragEnter() { console.log('event: ' , 'dragenter') }function addEventListeners(){ const draggables = document.querySelectorAll('.draggable') const dragListItems = document.querySelectorAll('.draggable-list li') draggables.forEach(function(draggable){ draggable.addEventListener('dragstart', dragStart); }); dragListItems.forEach(function (item) { item.addEventListener('dragover', dragOver); item.addEventListener('drop', dragDrop); item.addEventListener('dragenter', dragEnter); item.addEventListener('dragleave', dragLeave); });} click event將 HTML 所設定的 button，綁定一個click事件，呼叫checkOrder函式。 checkOrder()由於上面有設定 random 公式，當畫面 reload 時，是隨機排列的。我們將列表重新排序時，最後點下 btn，確認是否排列正確。設定變數videoName取得 listItem 裡的文字，將videoName跟原先設定好的listItem[]裡相同位置的文字進行比對。若不相同 ＝&gt;加上屬性 wrong若相同 ＝&gt;移除屬性 wrong增加屬性right 123456789101112131415$('#check-btn').click(checkOrder);function checkOrder(){ listItems.forEach(function(listItem, index){ const videoName = listItem.querySelector('.draggable').innerText.trim(); // console.log(videoName) if(videoName !== hottestVideo[index]){ listItem.classList.add('wrong'); }else{ listItem.classList.remove('wrong'); listItem.classList.add('right'); } })} tags: javascript","link":"/2021/01/28/JS%E7%B7%B4%E7%BF%92_%E5%8F%AF%E6%8E%92%E5%BA%8F%E8%A1%A8%E5%96%AE/"},{"title":"JS練習_登入頁面","text":"製作一個登入頁面，讓使用者得以輸入個人資訊，並設定輸入條件，像是： 功能 若使用者尚未輸入任何資訊或是輸入條件不符，輸入欄出現警示紅框 在信箱部分只能輸入信箱資料 在使用者名稱或密碼設定輸入字數條件 HTML 可以使用 vscode 快捷鍵 cmd +d 選取下一個相同的字。 使用 bootstraps 設定容器，使容器可以隨著螢幕伸縮改變，呈現 RWD 的效果 CSS visibility 屬性： visable : 產生的 box 是可見的 none : 產生的 box 是不可見的讓元素/物件隱藏起來 與 display:none 最大差別是，D-N 是整個屬性關閉 :root 使用：root 設定顏色變數，在做顏色調用時可以直接輸入變數取用 12345678:root{ --success-color:#2ecc71; --error-color: #e74c3c;}/*----取用時----*/h1{color: var(--success-color)} JS 先宣告變數，利用 getElementById 取得元素 加入 Eventlistener 事件監聽 註冊一個submit事件，這邊的e.preventDefault();是用來停止預設的 submit 這個行為： 1234// Eventlistenerform.addEventListener('submit', function(e) { //註冊事件 e.preventDefault(); //停止預設行為}) 並在事件裡導入判斷函式 showSuccess()/ showError() showError 功能 當輸入條件不符合時，設定的 tag &lt;small&gt;會顯示出錯誤訊息 利用元素.className 方法，加入form-group error屬性，帶入 css，使輸入匡變成紅色。 showSuccess 功能 沒有錯誤訊息，將 class 名稱改成form-group success來讓 css 可以正確將輸入框顯示綠色。 checkRequired 功能getFieldName返回將輸入的 id 資訊，第一個字母變成大寫。 - charAt(0)回傳第０個值，再加上後面的小寫字元 - slice([begin, end])回傳陣列，可選澤從開始到結束的值。 判斷判斷式是否輸入正確，將輸入的陣列資訊每個值透過forEach讀取，再利用trim()方法，將空白字串去除 123456789101112131415// Get fieldnamefunction getFieldName(input) { return input.id.charAt(0).toUpperCase() + input.id.slice(1);}// Check required fieldsfunction checkRequired(inputArr) { inputArr.forEach(function(input) { if(input.value.trim() === ''){ showError(input, `${getFieldName(input)} is required`); } else { showSuccess(input); } });} Email 格式驗證 透過別人寫好的 emial 驗證函式，直接帶入驗證，並加入 if 迴圈，設定不同情況所執行不同的 showError() 123456789function isValidEmail(input) { const re = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // return re.test(String(email).toLowerCase()); if(re.test(input.value.trim())) { showSuccess(input); } else { showError(input, 'Email is not valid'); }} 調整驗證機制原本一開始是設定 submit 事件，並在 function 帶入多項 if 迴圈判斷，但這樣顯得整個程式碼繁雜。可以透過導入設定好的判斷函式，簡化程式碼。 1234567891011form.addEventListener('keyup',function(e){ e.preventDefault(); checkRequired([username, email, password, password2]); checkLength(username, 3, 15); checkLength(password, 8, 16); isValidEmail(email); if(!checkRequired([password, password2])){ checkLength(password, 8, 16); checkPasswordMatch(password, password2); }}) 並已將 function checkLength/checkRequired/ isValidEmail 設定好在上面 checkLength 帶入三個參數，分別為 input, min, max，利用條件判斷要是input小於 或是 大於設定條件，就會帶入 showError()函式，否則就會導入成功函式 ‵‵或是${}是 E6 的新語法，可以在裡面放置變數 123456789function checkLength(input, min, max) { if(input.value.length &lt; min) { showError(input, `${getFieldName(input)} must be at least ${min} characters`); } else if (input.value.length &gt; max) { showError(input, `${getFieldName(input)} must be less than ${max} characters`); } else { showSuccess(input); }} tags: js_練習","link":"/2020/11/29/JS%E7%B7%B4%E7%BF%92_%E7%99%BB%E5%85%A5%E9%A0%81%E9%9D%A2/"},{"title":"JS_練習_終極密碼遊戲","text":"透過連接 API，製作聲音接收器，接收器辨識使用者的發聲，判斷是否符合設定的數字。 純 HTML 畫面 成品畫面 JSgetRandomNum()使用Math.random 創造 0 ~ 1 的數字，在乘上 100 且使用Math.floor讓產生數字 099，最後再加一。利用 console.log 檢查是否產生 0100 的數字 123456const randomNum = getRandomNum();console.log(&quot;number: &quot;,randomNum);function getRandomNum(){ return Math.floor(Math.random()*100) +1;} web Speech APIWeb Speech API 裡面有兩個功能「語音轉文字(Speech Recognition)」跟「文字轉語音(Speech Synthesis )」兩種，本次例子是使用後面「語音轉文字」這個部分。 因為每個瀏覽器支援的部分不同，在導入時要加上webkit字樣以方便我們驅動 API。 12window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 建構一個物件實體。使用 SpeechRecognition()建構式建立物件。 12//create objectlet recognition = new window.SpeechRecognition(); 常用方法： speechrecognition.start():讓 API 開始辨識。 result event 代表辨識使用這說的話，每段話都會存在 results 這個陣列裡面，如果要獲取所辨識的值，可以直接用數字從陣列中取出。 本例透過 result()呼叫getSpeakWord()這個方法; 12recognition.addEventListener('result', getSpeakWord); getSpeakWord()API 辨識使用者的發聲，可先以 console.log 檢查是否成功接收聲音。因為得到的是一串陣列，利用索引值取出聲音資料。 12345function getSpeakWord(e){ // console.log(e) const msg = e.results[0][0].transcript; console.log(msg)} SpeechRecognition 小科普 writeMessage()在 getSpeakWord 函式裡，呼叫寫入呼叫字的函式writeMessage()。 此函式為改變原先在 html 已設定好 id 為 msg 的 html 內容。 123456789function writeMessage(msg){ $('#msg').html( ` &lt;div&gt;You said:&lt;/div&gt; &lt;span class=&quot;box&quot;&gt;${msg}&lt;/span&gt; &lt;div&gt;Go Higher&lt;/div&gt; `);} checkNum()設定判斷條件，首先先設定變數 num，將+msg賦予給 num。這邊 ==+== 是代表將 string 型別的 msg 轉型為 number 型別。 確認是否為數字。 判斷與 randomNum 的大小別，給予提示。 猜對了顯示文字恭喜，結束遊戲。 end event使用 end event，重新呼叫 start() 讓使用者可以根據提示繼續猜下一個數字。.js recognition.addEventListener('end',function(){ recognition.start(); }) click event當猜對數字時，畫面有個 button，設定綁定點擊觸發 reload()事件，讓使用者能再玩一次。 123456//click eventdocument.body.addEventListener('click',function(e){ if(e.target.id == &quot;play-again&quot;){ window.location.reload(); }}) 刷新頁面小科普 tags: javascript","link":"/2021/01/23/JS%E7%B7%B4%E7%BF%92_%E7%B5%82%E6%A5%B5%E5%AF%86%E7%A2%BC%E6%A9%9F/"},{"title":"關於URL 的組成","text":"圖片來源 URL(Uniform Resource Locator)直譯是統一資源定位器，哈哈這啥？超級白話的中文其實就是 ==網址==。網址是什麼，就像是在現實生活中，每個家都有一個確切的地理位置，在網路世界也依樣，透過精確的位置，才能夠正確抵達採訪入口，成功造訪網頁。 網址結構1234https://tw.yahoo.com/https://tw.news.yahoo.com/entertainmenthttps://www.google.com/search?q=url&amp;source=lmns&amp;bih=691&amp;biw=1103&amp;rlz=1C5CHFA_enTW926TW926&amp;hl=zh-TW&amp;sa=X&amp;ved=2ahUKEwiTlrD0p4DwAhXTIaYKHWmhBGgQ_AUoAHoECAEQAA 一個 url 有幾個必須的組成項目，接下來一一介紹 Protocol就是最前面 https，有時候是 http，中超文本(安全)傳輸安全協定，指的是兩台電腦間溝通的一種協議，https 是比 http 更安全的協議，在傳送數據間，雙方電腦會將數據先進行加密並互相交換鑰匙，在收到對方電腦數據時，可以使用交換的鑰匙解密，解讀數據，增進數據的安全性。 hosthost 定義主機的 IP 與主機名稱，讓我們可以快速的查詢及被查詢以定義過的主機名稱及對應的 IP 位置。 1host = hostname+':'+ port 常見的定義： IP 位置 主機名稱 別名 127.0.0.1 localhost.www.mycorp.com localhost 192.168.168.1 www.mycorp.com www 像www就是主機名稱，而 mycorp.com 就是網域名稱。 port網址中 host 部分 後面冒號所接的一串數字，稱為 port(端口)，主要用來來解讀 IP 位置的管道。有個形容 port 的說詞，把 IP 位置想成一串電話號碼，port 就是電話號碼的分機。利用不同的port 編號代表不同對應的窗口，代表不同的網路服務。當電腦接收很多很多資料時，每個資料上都帶有不同的 port 編號，電腦會根據這些編號將資料轉交給不同的程式去執行。 path路徑，指的是造訪網站的路徑。 絕對路徑指的是完整的網址，像是https://google.com.tw含有完整得 https://+ hostname+ port 相對路徑根據現在所在的目錄+/+檔名作為參考基礎，而建立出的目錄路徑，若是在不同層(在另外一個目錄)則以../點點斜線回到上一層再以斜線前往相關目錄＋檔名。 query string查詢字串也被稱為參數(parameter)。 get/ post 請求中 url 後面要帶的參數。當發起 get 方法請求時，參數以 url string 形式進行傳遞，在?後面的 string 是請求參數，並以&amp;作為分隔符號 為獲得請求內容，向網頁伺服器傳遞的參數。 tags: html","link":"/2021/04/17/%E9%97%9C%E6%96%BCURL%20%E7%9A%84%E7%B5%84%E6%88%90/"},{"title":"Linux 的一些網路工具","text":"由於常用電腦為 MAC 系統，以下為 MAC 系統介紹 甚麼是 pingPing (Packet Internet Groper)，用來測試網路，檢查往是否通暢或是網路連接速度的命令。 常用指令，在終端機輸入ping 使用 ping 測試網路連通 使用 ipconfig /all 觀察本地端網路設置是否正確， 輸入 ping [想要查詢的網址] 查詢想要查詢的頁面。 curlcurl 是一個在 Linux 上用來透過 HTTP Protocol（HTTP HyperText Transfer Protocol 定義存取網路資源的協定，讓我們可以以 client / server 模式來取得網路資源）下載和上傳檔案的指令。它 基本指令：A.查看網頁原始碼curl [想要查看的網址]b.保存網頁資料curl -o [文件名][文件名的網址]c. 發送表單訊息，發送表單訊息有兩個方法，get/ postcurl -o [文件名][文件名的網址] wgetwget 是一個設置簡單 Linux 用戶下載文件的工具，用於終端機上，支持 FTP 及 HTTP 下載方式對於一般網路後端管理員，工作上需要遠端伺服器輝費備份來說主要使用的工具有下列幾項特點： 支持斷點下載功能。 何謂斷點下載？白話文來說就是不用重頭下載，可以就原本下載部分繼續下載，要是原本已下載 50%的檔案，就可以從 51%繼續下載而不是從 0 開始。 同時支持 FTP 和 HTTP 下載方式。儘管現在多用 HTTP 方式下載，但有時，仍然需要使用 FTP 方式下載軟體。 支持代理伺服器，對於安全度要求極高的系統來說，一般來說不會將自己的系統直接暴露在網路上，所以支持代理伺服器是必須的功能。 代理伺服器小科普 設定簡單方便。主要是以命令列操作，雖然現代人習慣帶有畫面圖片的視覺操作，但以命令列操作可以減少許多 bug wget 指令 基本下載檔案。用法： wget + 要下載的網址 1234//http版本wget http://ftp.gnu.org/gnu/wget/wget-1.19.tar.gz// ftp版本wget ftp://ftp.gnu.org/gnu/wget/wget-1.19.tar.gz 檔案續傳如果下載大型檔案中途斷線，檔案只下載了一部分，這時候可以使用 wget 的 -c 參數從上次中斷的地方繼續下載。 1wget -c http://ftp.gnu.org/gnu/wget/wget-1.19.tar.gz 限制檔案下載速度為防止 wget 在下載檔案時，佔用了全部的網路頻寬，可以使用 –limit-rate 參數指定檔案下載的速度上限值： 1wget --limit-rate=100k http://ftp.gnu.org/gnu/wget/wget-1.19.tar.gz 參考網站 tags: Linux","link":"/2021/05/01/Linux%20%E7%9A%84%E4%B8%80%E4%BA%9B%E7%B6%B2%E8%B7%AF%E5%B7%A5%E5%85%B7/"},{"title":"網路協議裡的一些名詞","text":"網路協議是計算機為了進行數據交換而建立的規則，就好比一台小手機為了跟遠端的超大伺服器進行通信，因為兩邊所使用的字符格式完全不同，你說你的Ａ他回答他的Ｂ根本無法進行溝通。為求溝通，訂定出必須先將各自的字符集先轉換成標轉的字符，才能進行網路傳送， IP 是什麼？IP 是整個 TCP/ IP 協議的核心，規定了數據資料傳輸的方法以及路由選擇，就像是可以決定現實生活中貨物的運送方法或及路線選擇。 DNS 是什麼？Domain Name Sever，是域名（Domain name)跟 IP 網址轉換的伺服器，DNS 有一張關於域名及對應的 IP 位置的表，用來把網路上的域名解析成 IP 位置，同一個域名可能有很多個 DNS，這樣可以降低負載 HTTP 是什麼？使用網際網路時，其實就在使用各種不同協定。想要瀏覽網頁，會使用到 HTTP。想要收發即時訊息，會使用到 XMPP。FTP 就是用來到處檔案移動的協定。HTTP 是個屬於應用層的協議，因為簡單且快速再 90 年後迅速發展。他主要有幾項特點： HTTP 是基於 TCP 協議上的一層應用每當客戶端發送一次請求，當處理完這個請求時，會自動釋放 簡單快速：當客戶像伺服器發出請求時，只要傳送請求方法與路徑，方法通常是 GET/ HEAD/ POST…，每種方法規定了客戶與伺服器的 無狀態:狀態，就是客戶端或者伺服器裡保存的一些數據或者標誌，記錄了通信過程中的一些變化信息。HTTP，客戶端和伺服器永遠處於一種「無知」的狀態，就是每次的請求和回應都是獨立的，沒有任何聯繫。就是協議不要求客戶端或伺服器記錄請求的相關信息。 夠可靠，HTTP 協議是一個==可靠度==相當高的傳輸協議：因為 HTTP 協議是基於 TCP/IP 的，而 TCP 本身是安全性很高，所以 HTTP 自然也就繼承了這個特性，能夠在請求方和答應發之間“可靠”的傳輸數據。其實 HTTP 也就是對傳輸的數據進行了一層包裝，加上一個頭，然後調用 Socket API，通過 TCP/IP 協議發送和接收。 除了 HTTP 還有那些網路協議？http 屬於應用層，SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP、TLS 還包含許多網路協議[smtp] UDP 與 TCP / IP 的分別是？OSI 參考模型中傳輸層有兩種協定，UDP 及 TCP，這兩個協定主要是為確保資料正確傳輸且可以控制流量。 比較 比較項目/協定 TCP UDP 速度 慢 快 穩定度 高 低 安全性 高 低 握手程序 需要 不需要 這兩個差別主要在於 TCP 是雙向傳輸 UDP 是單向.TCP 在傳送時會有封包數據，他可靠性高UDP 可靠性低.傳送東西速度快。 TCP 提供的是一個連線導向(Connection Oriented)的可靠傳輸﹐主要有幾個特點： 有握手程序握手程序主要是三向握手透過發出連線請求，連線確認及連線成功達成握手程序。 確認封包機制TCP 會利用確認及重送，確定資料平安順利的傳送，這個確認的過程也會留下封包紀錄作為下一筆資料確認的依據。 帶有計時器TCP 在發送資料後，會啟動一個計時器， UDP 則是一個非連線型(Connectionless)的非可靠傳輸協定﹐所謂非連線型代表不通知他要傳送就開始傳送資料，UDP 不會運用確認機制來保證資料是否正確的被接收、不需要重傳遺失的資料、資料的接收可不必按順序進行、也不提供回傳機制來控制資料流的速度。因此﹐UDP 信息可能會在網路傳送過程中丟失﹑重複﹑或不依順序﹐而且抵達速度也可能比接收端的處理速度還快。對於某些訊息量較大、時效性大於可靠性的傳輸來說(比方說語音 / 影像)，UDP 的確是個不錯的選擇。 tags: 網路名詞","link":"/2021/04/29/%E7%B6%B2%E8%B7%AF%E5%8D%94%E8%AD%B0%E8%A3%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8D%E8%A9%9E/"},{"title":"關於URL 的組成","text":"HTTPHTTP(HyperText Transfer Protocol)超文本傳輸協議，是網路上最廣為使用的一種網路協議。 特點 HTTP 是個用在計算機(電腦)世界裡的一種協議，他確立了電腦間相互通信的規範以及各種控制及錯誤的處理方式。 專門處理兩點間的傳輸，不能用於廣播、尋址或路由。 HTTP 傳輸的是文字圖片音樂視頻等超文本數據，在早期的計算機裡只是簡單的字符傳輸，所以是文本傳輸，但隨著時間的演變多了圖片音樂及影片的傳輸，就變成超越簡單字符的傳輸，可以透過超連結從文本 a 跳入文本 b，變成我們現在所看到的畫面。 是一個雙向協議。假設現在有兩方Ａ與Ｂ(回應方)要是Ａ先發請需求他就是(請求方)Ｂ就是(回應方)，由Ａ發出需求Ｂ接收後回應，數據在雙向間傳輸。 FTPFile Transfer Protocol(檔案傳輸協議)英文簡稱。FTP 是 TCP/IP 網路 (網際網路) 上的裝置用來傳輸檔案的一套規則。 運作FTP 是一種主從式協定。用戶端要求檔案，而伺服器則提供檔案。這樣一來，FTP 建立連線時需要兩種基本通道： 命令通道 (負責啟動指令並攜帶基本資訊，即欲存取哪些檔案) 資料通道 (在兩個裝置之間傳輸檔案資料)。為了建立連線，使用者需要向 FTP 伺服器提供登入資料，FTP 伺服器通常會將 21 號連接埠選為預設通訊模式。FTP 伺服器就是具備 FTP 位址且專門用來接收 FTP 連線的電腦。這些伺服器負責執行兩項簡單工作：「取得」與「放置」。 連線模式 主動模式：伺服器會主動核准資料請求。不過，主動模式有時可能會因防火牆而發生問題，即防火牆會封鎖來自第三方未經授權的工作階段。 被動模式：在被動模式下，伺服器不會主動維持連線，而是由使用者同時建立資料通道和命令通道。基本上，伺服器「聽令」但不主動參與，而是由其他裝置來處理大部分工作。 SSHSecure Shell 是由 IETF(The Internet ENgineering Task Force)制訂的建立在應用層上的基礎安全性協議，能夠把傳輸的東西進行==壓縮==及==加密==，壓縮加快資料傳輸的速度，加密可以增加資料安全性 SSH 是以非對稱的金鑰系統，透過兩把不同的鑰匙公鑰/ 私鑰進行加密與解密。 公鑰：提供遠端主機進行資料加密，大家可以用本地端提供的公鑰，對傳輸資料進行加密。 私鑰（不可外流）：在本地端對資料進行解密，本地端拿到大家上密後的資料，可以以 私鑰解密。 整個過程很像是： 小明小花採用非對稱式方法交換資料，他們首先相互交換雙方的公鑰 小明以私鑰將資料簽名，並用小花的公鑰把資料加密 小花取得小明給的資料， 以小明的公鑰確認資料是由小明所簽的並 以自己的私鑰把資料解密。 安裝 SSH 建立 SSH Key在本地端終端機輸入指令 ssh-keygen，可用來生成 SSH 公鑰匙和私鑰匙的文件。cd ~/.ssh前往放鑰匙的資料夾，看到 id_rsa.pu：公鑰 id-rsa: 私鑰 SMTPSimple Mail Transfer Protocol(檔案傳輸協議)英文簡稱。是網際網路上傳輸電子郵件的標準。 SMTP 協議屬於 TCP/ IP 協議應用層裡的一種協議，使每台計算機透過 SMTP 伺服器，將電子郵件寄到收件人的伺服器上。 SMTP 伺服器是遵循 SMTP 協議的郵件伺服器，用來發送及接收郵件。由本地端建立一個與 SMTP 伺服器的ＴＣＰ連接口，端口通常為 25，連結建立後，本地端與伺服器先執行應用層裡的握手操作，讓ＳＭＴＰ伺服器知道本地端的訊息，並對本地端作出回應。待握手完畢後，ＳＭＴＰ伺服器把由本地端發出的郵件訊息透過ＴＣＰ提供的數據傳輸把訊息準確的傳送到收件者的伺服器。 tags: 網路名詞","link":"/2021/04/30/%E9%97%9C%E6%96%BC%20HTTP_%20FTP_%20SSH_%20SMTP/"},{"title":"JS套件_AOS","text":"利用寫好的前端套件做出滾動捲軸時，能觸發區塊物件呈現滑進/ 滑出效果(FADE 突現、FLIP 翻轉、ZOOM 由大變小等。在官網尚有提供範例讓我們參考。 導入本地端CDN123456789//在&lt;head&gt;裡添加style 連結&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/aos@next/dist/aos.css&quot; /&gt;// 在&lt;body&gt;添加&lt;script&gt;連結並 init()初始化他。&lt;script src=&quot;https://unpkg.com/aos@next/dist/aos.js&quot;&gt;&lt;/script&gt;&lt;script&gt; AOS.init();&lt;/script&gt; 建議放在前面，避免 client 端瀏覽載入頁面時造成遲延(根據 DOM 的觀念，如果有再用 jquery 的一些特效，都盡量放在下方為宜)。 npm 下載終端機輸入 1npm install --save aos@next 再使用import 導入並初始化他 1234import AOS from 'aos';import 'aos/dist/aos.css'; // You can also use &lt;link&gt; for styles// ..AOS.init(); 參數初始化只需要在 script 標籤裡，利用AOS.init()即可啟用 AOS 套件，但我們也可以自訂參數初始化套件。 123456789101112//自定參數呼叫$(function(){ AOS.init({ offset: 120, = 以像素(px)為單位，水平移動 delay: 0, = 延遲時間，範圍：0~ 3000 duration: 400, = 動畫時間，範圍：0~ 3000 easing: ‘ease’, = 動畫速率效果 once: false, = 是否重複觸發動畫 mirror: false, = 是否超過滾動範圍時，做移出的動畫效果 anchorPlacement: ‘top-bottom’, = 滾動方向觸發動畫，預設由上到下 });}) 屬性說明除了透過參數設定，也可以直接在元件上利用 ==attribute==屬性決定。就像 1234567891011&lt;div data-aos=&quot;fade-up&quot; data-aos-offset=&quot;200&quot; data-aos-delay=&quot;50&quot; data-aos-duration=&quot;1000&quot; data-aos-easing=&quot;ease-in-out&quot; data-aos-mirror=&quot;true&quot; data-aos-once=&quot;false&quot; data-aos-anchor-placement=&quot;top-center&quot;&gt;&lt;/div&gt; data-aos = 呈現的效果 //fade、flip、zoom 任君挑選 data-aos-duration = 出場持續時間 //單位是毫秒，所以 1000 代表 1 秒 data-aos-delay = 遲延秒數 data-aos-offset = 卷軸滾到多少 px 才觸發 data-aos-easing = 動畫執行速度 //個人試過覺得效果不大 data-aos-once = 觸發一次或上下滾動都觸發 //用 true 或 false data-aos-anchor-placement = 滾動到哪才觸發這邊可用 top-bottom、center-bottom、bottom-bottom 等屬性值，建議後面的值維持-bottom 即可，若是後值改為 top 會發現怎麼滾了整大頁面才彈跳出來.. 例子成品 做一個滾動畫面，方塊就會從左右兩側進入HTML 部分 12345678&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot; data-aos=&quot;fade-right&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item&quot; data-aos=&quot;fade-left&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item&quot; data-aos=&quot;fade-right&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;item&quot; data-aos=&quot;fade-left&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;item&quot; data-aos=&quot;fade-right&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;item&quot; data-aos=&quot;fade-left&quot;&gt;6&lt;/div&gt;&lt;/div&gt; CSS 部分 12345678910111213141516171819202122.contianer { width: 100%; height: 100%;}.item { width: 200px; height: 200px; margin: 20px auto; display: flex; justify-content: center; align-items: center;}.item:nth-child(even) { background-color: red;}.item:nth-child(odd) { background-color: blue;} JS 部分 12//是的，只有初始化( ´ ▽ ` )ﾉAOS.init(); tags: javascript 套件","link":"/2021/06/01/JS%E5%A5%97%E4%BB%B6_AOS/"},{"title":"JS套件_Swiper","text":"swiper 是常用的網頁跑馬燈及幻燈片的套件，市場上使用的人非常多，相容性也相當高，以下就實作練習中使用的部分寫出心得。 安裝 CDNswiper 當然也有出很多版本，此篇心得就目前最新版本 swiper 6 展示。 - 官網的 CDN 連結： 1234567//css的部分&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/swiper/swiper-bundle.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/swiper/swiper-bundle.min.css&quot; /&gt;//js 的部分&lt;script src=&quot;https://unpkg.com/swiper/swiper-bundle.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/swiper/swiper-bundle.min.js&quot;&gt;&lt;/script&gt; 下載本機 官網載點 NPM 安裝 1$ npm install swiper 例子實例：一張圖片輪播 成品:左右箭頭版(navigation) 成品：下方點點串(pagination) html 部分12345678910111213141516171819202122&lt;!-- Swiper --&gt;&lt;!----必要！最外面一定要包一層swiper-container---&gt; &lt;div class=&quot;swiper-container&quot;&gt; &lt;!----必要！最外面也要再包一層swiper-wrapper---&gt; &lt;div class=&quot;swiper-wrapper&quot;&gt; &lt;div class=&quot;swiper-slide&quot;&gt;&lt;img src=&quot;https://fakeimg.pl/350x200/?text=slide_1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;&lt;img src=&quot;https://fakeimg.pl/350x200/?text=slide_2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;&lt;img src=&quot;https://fakeimg.pl/350x200/?text=slide_3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;&lt;img src=&quot;https://fakeimg.pl/350x200/?text=slide_4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;&lt;img src=&quot;https://fakeimg.pl/350x200/?text=slide_5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-slide&quot;&gt;&lt;img src=&quot;https://fakeimg.pl/350x200/?text=slide_6&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 非必要! 分頁 --&gt; &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; &lt;!-- 非必要! 上/下一頁按鈕 --&gt; &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt; &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt; &lt;/div&gt; css123456789101112131415161718192021222324252627.mySwiper { width: 100%; height: 100%; background-color: red;}.swiperslide { width: 100%; display: flex; justify-content: center; align-items: center; text-align: center; font-size: 18px; background-color: yellow;}.swiperslide:nth-child(even) { background-color: blue;}.swiper-slide img { display: block; width: 100%; height: 100%; object-fit: cover;} JS 部分 1234567891011//ㄔ var swiper = new Swiper('.mySwiper', { // navigation: { // nextEl: &quot;.swiper-button-next&quot;, // prevEl: &quot;.swiper-button-prev&quot;, // }, pagination: { el: &quot;.swiper-pagination&quot; }, }) 實例：三張圖片輪播成品JS 新增屬性 12345678910111213var swiper = new Swiper('.mySwiper', { // navigation: { // nextEl: &quot;.swiper-button-next&quot;, // prevEl: &quot;.swiper-button-prev&quot;, // }, pagination: { el: &quot;.swiper-pagination&quot; }, slidesPerView: 3, spaceBetween: 30, freeMode: true,}) 實例：三張圖片，播完後又從第一張開始，無限輪迴12345678910111213141516var swiper = new Swiper('.mySwiper', { // navigation: { // nextEl: &quot;.swiper-button-next&quot;, // prevEl: &quot;.swiper-button-prev&quot;, // }, pagination: { el: &quot;.swiper-pagination&quot;, clickable: true, //才可以點 }, slidesPerView: 3, spaceBetween: 30, freeMode: true, loop: true, loopFillGroupWithBlank: true,}) 實例：三張圖片，自動播放播完後又從第一張開始，無限輪迴1234567891011121314151617181920var swiper = new Swiper('.mySwiper', { // navigation: { // nextEl: &quot;.swiper-button-next&quot;, // prevEl: &quot;.swiper-button-prev&quot;, // }, pagination: { el: &quot;.swiper-pagination&quot;, clickable: true, //才可以點 }, slidesPerView: 3, spaceBetween: 30, freeMode: true, loop: true, loopFillGroupWithBlank: true, autoplay: { delay: 2500, disableOnInteraction: false, },}) tags: javascript 套件","link":"/2021/06/03/JS%E5%A5%97%E4%BB%B6_Swiper/"},{"title":"JS套件_Slick","text":"介紹Slick 是個很像 Swiper 套件的一個 jQuery 響應式幻燈片套件，支援 IE+8, Chrome, Firefox and Safari 官方文件連結 起手式 引入 cdn，當然也可以載入本地端，以後直接呼叫套件 1234567//css·部分&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.css&quot;/&gt;// jQuery部分&lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot; integrity=&quot;sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;//js部分（注意！套件js部分需設定在jQuery之後）不然會沒反應&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.min.js&quot;&gt;&lt;/script&gt; 例子 - 完成一個自動輪播的一頁３個的輪播畫面 完成畫面 HTML 部分 12345678910&lt;div class=&quot;show-box&quot;&gt; &lt;div id=&quot;pic-box&quot;&gt; &lt;img src=&quot;https://fakeimg.pl/350x200/?text=Hello-1&quot;&gt; &lt;img src=&quot;https://fakeimg.pl/350x200/?text=Hello-2&quot;&gt; &lt;img src=&quot;https://fakeimg.pl/350x200/?text=Hello-3&quot;&gt; &lt;img src=&quot;https://fakeimg.pl/350x200/?text=Hello-4&quot;&gt; &lt;img src=&quot;https://fakeimg.pl/350x200/?text=Hello-5&quot;&gt; &lt;img src=&quot;https://fakeimg.pl/350x200/?text=Hello-6&quot;&gt; &lt;/div&gt;&lt;/div&gt; css 部分 12345678910111213141516171819body { margin: 0; padding: 0; background-color: aquamarine;}.show-box { margin: 0 auto; width: 90%;}#pic-box { width: 100%;}img { margin: 20px;} JS 1234567891011121314 $(function () { $('#pic-box').slick({ //.slick初始化 slidesToShow: 3, //一次幾頁 infinite: true, //無限回撥 dots: true, //有沒有下面的點點 arrows: true, //設定左右兩邊箭頭（注意預設為白色） autoplay: true, //會不會自己自動播放 autoplaySpeed: 1000, //自動播放的速度 centerMode: true, //自動置中顯現 }) })}); tags: javascript 套件","link":"/2021/06/02/JS%E5%A5%97%E4%BB%B6_slick/"},{"title":"JS_觀念_JSON筆記","text":"什麼是 JSONJSON 是一種資料交換格式，是個以純文字為基底去儲存和傳送簡單結構資料。 可以透過特定的格式去儲存任何資料(字串,數字,陣列,物件) 透過物件或陣列來傳送較複雜的資料 一個 JSON 例子以 JSON 描述我開的車，我們可以看到 JSON 檔是個以 key / value 所構成的檔案，在裡面 Value 可以為字串/ 數字/ 布林值/ 物件或是陣列 12345678910var myCar = { &quot;brand&quot;: &quot;Toyata&quot;, &quot;color&quot;: &quot;white&quot;, &quot;displacement&quot;: 1800, &quot;payoff&quot;: true, &quot;details&quot;:[ nickName: '小白', year: 2016 ]} 常用的方法 JSON.stringify() 將 array 轉成 string JSON.parse() 將 string 轉成 array 要是今天我們要將資料存入 localstorage，但因為 localstorage 只會存入 string 型別的資料，那我們需要先把 JSON 檔轉成 string 檔 以剛剛的例子 1234567891011//先將資料轉乘字串存入localstorage var stringData = JSON.stringify(myCar) console.log(typeof (stringData)) localStorage.setItem(myCar, stringData) console.log(localStorage.getItem(myCar))// 需要使用存入localstorage的資料時再將其取出 var getItem = localStorage.getItem(myCar); var arrData = JSON.parse(getItem); console.log(typeof (arrData)) console.log(arrData.brand) 結果 tags: javascript","link":"/2021/06/05/JS_%E8%A7%80%E5%BF%B5_JSON%E7%AD%86%E8%A8%98/"},{"title":"Javascript_觀念_hoisting","text":"什麼是 hoisting提升？提升什麼？提升是一個觀念，可以指==變數提升==或是==函式提升==，電腦就像人類的大腦一樣我們要指派給他做很多事情，每件事情都有自己的儲存空間(記憶體)需先宣告在電腦上才能運行，要是沒有宣告直接取用就是空殼記憶體，啥也沒有，。 只要變數都有在 scope 前被宣告，使用時就不用擔心，出現undfine，referenceError! 先宣告在使用！！！！ 變數提升1234567891011console.log(&quot;1.&quot;, x);var x = 1;function dodo() { console.log(&quot;2.&quot;, x);}console.log(&quot;3.&quot;, x);x = 2;console.log(&quot;4.&quot;, x); 例子１上面有一段程式碼，有四個 console.log，用網頁檢視會出現？ console 因為我們在下面還有宣告變數 x，所以他不會出現not defined，而是會undefined。 console 在函式dodo裡面，我們外面沒有呼叫dodo()所以不會出現。 console，因為我們在 dodo()上面有先宣告 var x =1 ，所以這裡會是 1。 console，我們將２賦予給 x，x 現在是 2 函式提升函式也可以提升，依樣秉持著一原則「先宣告，再使用」 例子一 123456console.log(trytry(11));function trytry(x){ x =10;console.log('try:',x) } console，印出來是 undefined 沒有問題，因為我們 fuc 在他放面才宣告。 console，印出來是 try: 10，再函式裡面就已經找到 x，所以印出來的值是 10 而不是 11。 例子二 1234console.log(trytry(11));function trytry(x){console.log('try:',x) } console，印出來是一樣是 undefined 沒有問題。 console，印出來是 try: 11，再函式裡面就==沒有找到==，在外面找到 11 作為參數傳進來 x，所以印出來的值是 11。 tags: javascript","link":"/2021/04/09/JS_%E8%A7%80%E5%BF%B5_hoisting/"},{"title":"Javascript_觀念_閉包(Closure)","text":"範圍鏈 Scope Chain 外層取不到內層宣告的變數，但內層可以讀取外層宣告的變數。 例子一: 123456789101112function outer() { b = a * 2; function inner(c) { console.log(&quot;a:&quot;, a, &quot;b:&quot;, b, &quot;c:&quot;, c) } inner(b * 3);}var a = 1;var b = 5;var c = 10;outer(a); 結果： 最裡面的 console.log(a, b, c)在最裡面沒有 abc 的宣告，一層層到外面找，直到找到全域變數有宣告 a/b/c。 但在函式裡 b 被指派由 a 值計算，c 又被指派由 b 計算，在裡面的變數不受外面影響，最後得到的結果是 a:1/ b:2/ c:6。 閉包 Closure再 MDN 上面的解釋是: 閉包（Closure）是函式以及該函式被宣告時所在的作用域環境（lexical environment）的組合。 很好看不懂，換個方式說，當內部函式被回傳時，除自己本身程式碼以外，內部函式內的變數會只會在內部函式，不被外面汙染。也就是一個 函式 回傳另一個 函式。 例子： 123456789101112131415var msg = &quot;global&quot;function outer(msg) { var msg = 'local'; function inner() { return msg } return inner;}var innerFunc = outer();var result = innerFunc()console.log(result); // 結果是：local 雖然是在外面呼叫outer()，都只會回傳inner()裡面的 msg，而不是全域變數的 msg。 計時器（有閉包 v.s 沒閉包） - 沒閉包 12345678for (var i = 1; i &lt;= 5; i++) {setTimeout(function timer() {console.log(i); }, i * 1000)}; i 直到六才迴圈終止，所有這個函式跑出來 666666，六次的六。 有閉包 123456789for (var i = 1; i &lt;= 5; i++) { function cldemo(){ var j = i; setTimeout(function timer() { console.log(i); }}, i * 1000)}; 12利用變數 j 儲存每一次的 i ，這個 i 是有用閉包包起來的，當時間過一秒時 j 是一，過兩秒時 j 是二，console.log 出來就會是 1/2/3/4/5。 tags: javascript,觀念","link":"/2021/04/09/JS_%E8%A7%80%E5%BF%B5_Closure(%E9%96%89%E5%8C%85)/"},{"title":"JS_觀念_var&#x2F; let&#x2F; const","text":"關於對變數的宣告方式，從一開始的var，到 ES6 出現let還有const，以下來理解他們之間的差別。 作用域 初始賦值 重複聲明 變量提升 改變值 var 函式範疇 可不用 可以 會 可以 let 區塊範疇 可不用 不行 不會 可以 const 區塊範疇 必須 不行 不會 不能變 varvar 是在 ES6 之前用來定義變數的方式，今天想要定義變數 x，要先以 var 宣告，電腦才會給 x 一個記憶體空間，儲存他的內容，是屬於全域變數。在全域環境下使用 var 聲明一個變量，電腦會默認他是掛載在最高層級的對象 window 上（在 Node 是 global）。 12var num = 1console.log(window.num) // 1 即使寫在函式裡，若沒有 var 宣告的變數還是會變成全域函數，裡面找不到，就會往外面找，也就是提升現象。 1234567891011var a = 1;var c= 100;function add(b){ console.log(a); //undefined var a =10; return a+b+c}console.log(add(5)); //115console.log(a)//1 由於 i 是全域變數，全域裡只有一个變數 i，for-loop 结束时，i=10，所以 i 也都是 10，而且陣列 a 裡也都是 10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[6](); // 10 letlet 跟 var 很像，和 let 的差別在於宣告變數的範圍，以及不能被重複宣告，var 是屬於作用域是函式範疇，let 則是區塊範疇。因為 let 是屬於區塊範疇，所以變數的宣告使用只能在區塊範疇{}中，其他地方是不能使用的。根據剛剛 var 的例子，要是我們想要印出的陣列是數字 1~10，該如何呈現？ 12345678var a = [];for (let i = 0; i &lt; 10; i++) { //每次循環i都是新的變量 a[i]=function(){ console.log(i) } //JavaScript 引擎内部會記住上一輪循環的值，初始化本輪的變數時，就會在上一輪循環的基礎上進行計算。}a[6](); //6 還有另外一個特點，不予許重複聲明 123let x = 1let x = 2// Uncaught SyntaxError: Identifier 'x' has already been declared constconst = 常數，他也是屬於區塊範疇，和 let 最大的差別在於他只能夠宣告一次，就不能在被改變了，而且初次宣告就要賦值，不然會出錯。今天有個變數 x 以 const 宣告，並指派數為數字１，那 x 就永遠是１。 tags:javascript 觀念","link":"/2021/06/09/JS_%E8%A7%80%E5%BF%B5_var_%20let_%20const/"},{"title":"Javascript_觀念_不一樣函式","text":"匿名函式 沒有名字的函式 只有在自己的函式區塊內有效 123456var add = function (a, b){ a=3; b=5; return a+b}console.log(add())//8 立即函式(IIFE) 在函式被創造時，立刻執行 利用()，將函式放在括號裡，因為括號=最高優先權的運算子，所以在括號裡的都會優先執行。 例子 12345var fruit = &quot;apple&quot;;(function callName(name){ var saying = &quot;is a good item.&quot; console.log(name+ saying)})(fruit); //apple is a good item. 一級函式(first-class functions) 函式就像變數一樣，可以存放在變數/物件/陣列中，也可以當參數傳入另外一個函式中 123function firstClass(fn, arr){ return fn //函式被當作參數，也可以回傳。} 箭頭函式() ES6 後才有的新語法，利用省去文字 function，以括號()/大於等於=&gt;以及大括號{}表達函式。 沒有引數(arguments) 例子 12345678//原本的寫法let oldOne = function old(name){ console.log(name+'is the old one');}//箭頭函式的let newOne = (name)=&gt;{ console.log(name+'is the new one');} 寫成 IIFE 的箭頭函式 1234//箭頭函式的IIFE()=&gt;{ console.log(apple+'is the new one');})() 回呼函式（Callback function) 在函式裡執行另外一個函式，並等原本的函式執行完，再做其他事。 例子：這裡有函式 A 與函式 B，但因為有設定Math.random()，所以不知道到底是會先印出函式Ａ還是函式Ｂ？ 但把函式Ｂ當作參數帶入函式Ａ，函式Ｂ就會先在外面執行後，等函式Ａ執完畢後，再接續印出。 12345678910111213141516const funcA = function (fnx) {const i = Math.random() + 1;window.setTimeout(() =&gt; { console.log('function A') if (typeof fnx == 'function') { funcB();}, i * 1000)}const funcB = function (fnx) { const i = Math.random() + 1; window.setTimeout(() =&gt; { console.log('function B')}, i * 1000)};funcA(funcB) tags: javascript 觀念","link":"/2021/06/11/JS_%E8%A7%80%E5%BF%B5_%E4%B8%8D%E4%B8%80%E6%A8%A3%E5%87%BD%E5%BC%8F/"},{"title":"Javascript_觀念_事件冒泡&#x2F; 捕獲","text":"事件，是一個媒介，有被觸動(動作)才會有對應的程式碼去執行。 生活的例子：開車。車子原本就在那邊你沒有發動引擎車子是不會動的，還是原封不動的躺在那，那發動引擎就是一個事件，我認為可以把它想成一個動作，做了這個動作才會 xxx。 事件流程網頁元素接收事件的順序。 假設有個 html 網頁內容如下： 1234567891011&lt;body&gt; &lt;div class=&quot;container1&quot;&gt; &lt;ul class=&quot;ul_container&quot;&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; 當網頁被瀏覽器載入時，瀏覽器會先分析 html 檔案並把內容解析成很多個網頁元素(DOM)，剛剛提到事件是個動作，就是對這很多個網頁元素所作的動作。 圖片來源- w3c document 這張圖是經典的事件流程圖，主要可以分為三個部分：事件冒泡與事件捕獲，兩個都會執行。 事件捕獲(Capturing)(紅) 由上到下 假設今天我們把圖中的&lt;td&gt;標籤綁定點擊事件，捕獲的事件流程是 document html body table tbody tr 目標階段，抓到要找的 Target(藍) 找到 target &lt;td&gt; 事件冒泡(Bubbling)（綠） 由下到上 一樣例子 假設今天我們把圖中的&lt;td&gt;標籤綁定點擊事件，冒泡的事件流程是 tr tbody table body html 回到 document 當我們為id名稱為：tdid的元素綁定點擊事件時，假設&lt;td id = &quot;tdid&quot;&gt;&lt;/td&gt; 12345var tdid = document.getElemenById(&quot;tdid&quot;);tdid.addEventListener(&quot;click&quot;, function () { console.log(&quot;td被點擊了&quot;);}); 瀏覽器會先執行事件捕獲向下找 id 名稱相符的 td 元素，這就是捕獲。在回傳回去 document 就是冒泡，像泡泡一樣向上傳遞給 document。 取消事件傳遞為什麼要取消事件傳遞，因為要是沒有取消的話，我們在編制 html 文件時，常常是一層包一層，我們今天在最裡面增添事件，沒有阻止事件冒泡的話，那外面每一層元素的事件都會被我一起觸發，減少網頁效率。 由上圖我們可以知道事件的流程分為兩條線，事件捕獲或是事件冒泡，這兩條線不論哪條，都可以利用e.stopPropagation進行中斷。 例子 結果只有： 要是我們勾選 Stop propagation，就只會可以得到alert div1，因為我們在 func1 設定了stopPropagation，所以事件不會傳遞到外面的div2，stopPropagation 添加在哪，事件就只會到他那邊而已。 html 部分： 1234567891011&lt;body&gt;&lt;h1&gt;The stopPropagation() Method&lt;/h1&gt;&lt;p&gt;Click DIV 1:&lt;/p&gt;&lt;div onclick=&quot;func2()&quot;&gt;DIV 2 &lt;div onclick=&quot;func1(event)&quot;&gt;DIV 1&lt;/div&gt;&lt;/div&gt;Stop propagation:&lt;input type=&quot;checkbox&quot; id=&quot;check&quot;&gt;&lt;/body&gt; JS 部分： 12345678910111213&lt;script&gt;function func1(event) { alert(&quot;DIV 1&quot;); if (document.getElementById(&quot;check&quot;).checked) { event.stopPropagation(); }}function func2() { alert(&quot;DIV 2&quot;);}&lt;/script&gt; 取消預設的行為e.stopPropagation 和 e.preventDefault常常被拿來做比較。 再次確認定義：e.stopPropagation：取消事件的傳遞。e.preventDefault：取消預設的行為。 例子:取消超連結的連結 1&lt;a id=&quot;a-link&quot; href=&quot;https://google.com&quot;&gt;google&lt;/a&gt; 通常點擊google就會連結的 google 的首頁，a 標籤預設有連結網頁的功能，我們現在要把他取消。 123document.getElementById(&quot;a-link&quot;).addEventListener(&quot;click&quot;, function(event){ event.preventDefault()}); 增加了只要點擊id：a-link的物件，就會把預設的行為(超連結)停止，這樣怎麼點也點不到 google 首頁。 tags: javascript","link":"/2021/04/09/JS_%E8%A7%80%E5%BF%B5_%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1_%20%E6%8D%95%E7%8D%B2/"},{"title":"Javascript_觀念_函式及作用域","text":"函式是一個指令或多個指令一起被包在括號裡面，可以重複被調用的==物件==。 定義方式函式宣告 表示式：JS 可以指派 function 給一個變數（其他語言無法） 例子一 1234567var x = function(){return &quot;123&quot;}//x() 可直接執行 結果-&gt;123 直接式：直接定義函式 例子二 1234567891011function add(a, b){return a+b}add(2,3) //結果5minus = function(x,y){return x-y}minus(100,10) 函式運算以剛剛例子二範例，我們函式 add，會回傳參數 a 與參數 b 的相加結果，這個就是內的運算 函式可以做的事函式是一個物件，物件可以做的事，函式都可以做。 可以當作參數被傳入 1234567//原本的funcAfunction funcA(){xxxx}var newA = function oddA(funcA){console.log(&quot;函式可以當作參數&quot;)} 可以有自己的屬性 1234567//原本的funcAfunction funcB(){xxxx}funcB.name = &quot;bb&quot;console.log(funcB.name); //結果是 bb} 可以被呼叫 1234567//原本的funcCfunction funcc(){console.log(&quot;我是 funcC&quot;)}funcC()//結果是 我是 funcC} 可以沒有名字 123456let ans = function (a,b){return a+b}consolo.log(ans) //結果是 a+b 作用域 Scope函式內所定義的變數只屬於==函式內==使用。 12345678var x = 100;function hi(x){var x =10;console.log(&quot;x現在是：&quot;, x);}hi(); //得到的結果是 x現在是：10;console.log(x) 得到的結果是 100; 同樣的變數在全域裡 x 是 100，但是在函式 hi 裡，x 有被指派新的值，但這也僅限在函式內部使用，在外面 x 還是全域變數 100。 tags: javascript,觀念","link":"/2021/04/09/JS_%E8%A7%80%E5%BF%B5_%E5%87%BD%E5%BC%8F%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"Javascript_觀念_解構賦值","text":"什麼是 hoisting 解構賦值 (destructuring assignment) 就跟照鏡子一樣，是 ES6 語法滿常用到的語法，以下就了解寫下筆記。 特點 如果解構失敗，變數的值就是 undefined 如果等號右邊不是陣列或物件結構會失敗 例子陣列的解構+ 賦值123let words = ['aa','bb','cc'];let[dd, ee, ff]=words;console.log(dd); //aa 函數的解構+賦值123456789function func({a = 1, b}) { return a + b}func({a: 2, b: 3}) // 5func({b: 3}) // 4func({a: 1}) // NaN，因為b沒有給預設值func({}) // NaN，因為b沒有給預設值func() // Cannot read property 'a' of undefined 物件的解構+賦值12345678910111213let obj = { name: 'chris', age:10, aa:{ c:'apple' }}let {name,age,aa: {c}} = objconsole.log(name); //chrisconsole.log(age) //10console.log(c); //aalet {aa: {c:d}} = obj //把d再指派給cconsole.log(d); //aa 物件的解構賦值，在對取出 JSON 資料時方便我們取出 key 值及鍵值。 -參考資料 tags: javascript 觀念","link":"/2021/06/21/JS_%E8%A7%80%E5%BF%B5_%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC/"},{"title":"JS_觀念_變數","text":"每本程式書籍，第一個介紹的東西不外乎就是變數，以下就學到目前為止對變數的理解心得如下： 變數是什麼？變數英文 variable，按中文直翻『會變的數』，是 JS 語言裡用來儲存資料用來運算的一個基本單位。 變數的宣告剛剛有提到變數是用來儲存資料跟運算的一個單位，我們今天要使用它，要執行把一個值儲存在一個變數上，就必須做==宣告== 這件事。在ＪＳ我們利用var這個英文單字後面加上變數名。 例子１：假設我們今天有一個變數是叫做 豬，我們可以直接宣告var pig;y0例子２：假設我們今天要宣告 車票價錢五十元這件事，我們會這樣寫var ticketPrice = 50 這裡使指有一個名為 ticketPrice 的變數他被賦予５０這個數字，所以下次再次呼叫 ticketPrice 時，就會得到他的數值５０，要是今天票價漲價了變成一百塊我們一樣可以再次修改賦予的值以 1var ticketPrice = 100 重新賦予在變數 ticketPrice 上。 命名規則 以$或是_或是字母作為開頭 大小寫有別。Apple 跟 apple 是兩種不同的變數名 不能用保留字，像是var以及 ES6 所出現的let或是const以及函式名function 都不能夠作為變數的名字。 tags:javascript 觀念","link":"/2021/06/08/JS_%E8%A7%80%E5%BF%B5_%E8%AE%8A%E6%95%B8/"},{"title":"Javascript_觀念_Array_1_forEach()&#x2F;map()","text":"在 JS 中，陣列是個物件，沒有長度或型別規定。 宣告 array 數組/陣列var car = [&quot;toyata&quot;, &quot;volvo&quot;, &quot;BMW&quot;]; 取得陣列值，透過索引值由 0 開始，上述例子 car[0]=&gt;toyota 改變原始陣列，有許多屬性/方法 如 push()、pop()、shift()、unshift()、reverse()、slice(a,b,c)、sort()排序…. 方法forEach() 把我們想要執行的函式，從頭到尾逐一（iterates through）的把陣列裡的元素帶進去這個函式處理一遍 語法 arr.forEach(function callback(currentValue[, index[, array]]) { //your iterator }[, thisArg]); callback 函式必須，其餘兩個是 optional 取得加總數123456let list = [5,10,20,30]let sum = 0;list.forEach(function(x) { sum += x;});console.log(sum); // 65 印出帶有索引值，多了第二個參數12345678910111213let list2 = [1,2,3,4,5]list2.forEach(function(el, index) { console.log(&quot;list2[&quot;+index+ &quot;]=&quot;+el );});//&quot;list2[0]=1&quot;&quot;list2[1]=2&quot;&quot;list2[2]=3&quot;&quot;list2[3]=4&quot;&quot;list2[4]=5&quot;// 把整個陣列列印，多了第三個參數他會根據你的陣列個數列印幾多少次的整個陣列 123456789101112131415161718let list3 = [1,2,3,4,5]list3.forEach(function(el, index,arr) { console.log(arr);});// [object Array] (5)[1,2,3,4,5]// [object Array] (5)[1,2,3,4,5]// [object Array] (5)[1,2,3,4,5]// [object Array] (5)[1,2,3,4,5]// [object Array] (5)[1,2,3,4,5] 統計出現次數這裡有一個觀念，要是陣列裡待有純字串的數字或是字串，當我們在使用 forEach 時，要是他本身沒有在原陣列被宣告，那字串及指定的值會變成key:value的方式呈現。 123456789101112131415161718let list4 = ['a','b','a','c','a'];let count ={};list4.forEach(function(el) { if(count[el]){ count[el]++; }else{ count[el]=1 }});console.log(count)// 印出的結果[object Object]{ &quot;a&quot;: 3, &quot;b&quot;: 1, &quot;c&quot;: 1} map()將原始的變數運算後重新組合一個 ==新的陣列==，記得一定要重新指派給新的變數，不然原本的陣列是不會被改變的。 語法 let new_array = arr.map(function callback( currentValue[, index[, array]]) { // return element for new_array }[, thisArg]) 沒有重新指派 123456let arr = [1,2,3];arr.map((el)=&gt;{return el *2})console.log(arr); //依然是 [1,2,3] 對每個陣列元素加工 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let arr1 =[1,2,3];let arr2 = arr1.map(element)=&gt;{ return element+1;}console.log(arr2);印出來的結果//arr2[2,3,4]---------------------------------let products =[ { name: 'iphone', price: 100, count: 10 }, { name: 'iMac', price: 1000, count: 5 }, { name: 'iPod', price: 70, count: 9 }];let info = products.map(item=&gt;({ name: item.name, totalValue: item.price * item.count}));console.log(info);印出來的結果// [object Object]{ &quot;name&quot;: &quot;iphone&quot;, &quot;totalValue&quot;: 1000},// [object Object]{ &quot;name&quot;: &quot;iMac&quot;, &quot;totalValue&quot;: 5000},// [object Object]{ &quot;name&quot;: &quot;iPod&quot;, &quot;totalValue&quot;: 630}] 把 String 陣列轉為數字陣列 12345let str = ['1', '2', '3', '4'];let numbers =str.map(Number);console.log(numbers);印出來的結果是//[1, 2, 3, 4] 對陣列元素校正 12345678910let arr1 =[1,2,3,4,5,6];let arr2 = arr1.map(element)=&gt;{ if(arr1&gt;3) =&gt;{ return 3; } return element;}console.log(arr2);印出來的結果是//arr2[1,2,3,3,3,3] tags: javascript","link":"/2021/06/09/JS_%E8%A7%80%E5%BF%B5_Array_1_forEach()_map()/"},{"title":"JS_練習_電影院網站實做","text":"將目前所學之框架 jQuery/ Bootstrap/ Vue 架設一個電影院網站，完成的頁面有 首頁 立即購票 現正熱映 即將上片 戲院介紹 首頁在首頁最上方是廣告的輪播所使用的 bootstrap 的內容 carousel，每二秒可以整屏替換。 利用 JS 套件 swiper 完成輪播功能，並增添連結及hover效果，使碰到卡片時前往介紹頁面。 立即訂票/購票頁面 放上現正熱映之影片並可以連結至購票頁面。 購票頁面利用Vue方式編寫此頁 - 利用點擊跳下一步，畫面跟著更新，不用寫四個 html 只需要在一個 html 裡透過v-bind綁定 step，並設定每一個step的display，就可以呈現每一步的畫面。 - 資料都有透過 vue 的 computed 放在 vue 裡，所以在每一畫面都可以透過再透過 v-bind 呈現資料資訊。 現正熱映/電影介紹現正熱映現正熱映頁面即是透過 bootstrap 框架放置電影資訊，帶有 hover 並顯示more效果，並且增設連結可以連到詳細電影介紹頁面。 電影介紹說明電影詳細資料，並增設留言板的功能，使使用者可以留下評分及影評，另外還有排序功能，可以依留言時間或是星星數呈現排序結果。 即將上映利用樹狀圖呈現電影資訊，並透過 JS 套件AOS當 load 畫面時，電影圖片會產生動畫效果，且設定 RWD，在大小不同的裝置時有不一樣的呈現。 戲院介紹 側邊表單此頁面資訊資訊內容較多，爲避免使用者快速得知資訊在大裝置上增設側邊表單，方便使用者快速瀏覽該部分資訊。 google MAP API最後的 googlemap ＡＰＩ除了一般文字的資料資訊，透過 API 的可以將帶有標記的 google 地圖呈現在網頁上，還可以放大或縮小查看詳細的標記地點附近的地址資訊。 tags: javascript","link":"/2021/07/05/JS%E7%B7%B4%E7%BF%92_%E9%9B%BB%E5%BD%B1%E9%99%A2%E5%AF%A6%E5%81%9A/"}],"tags":[{"name":"css","slug":"css","link":"/tags/css/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"command_line","slug":"command-line","link":"/tags/command-line/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"JS_練習","slug":"JS-練習","link":"/tags/JS-%E7%B7%B4%E7%BF%92/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"PesodoCode","slug":"PesodoCode","link":"/tags/PesodoCode/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"JS觀念","slug":"JS觀念","link":"/tags/JS%E8%A7%80%E5%BF%B5/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"網路名詞","slug":"網路名詞","link":"/tags/%E7%B6%B2%E8%B7%AF%E5%90%8D%E8%A9%9E/"},{"name":"JS套件","slug":"JS套件","link":"/tags/JS%E5%A5%97%E4%BB%B6/"}],"categories":[]}